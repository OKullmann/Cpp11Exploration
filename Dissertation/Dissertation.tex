\documentclass[11pt]{report}
\usepackage{a4}
\usepackage{graphicx}
\usepackage{hyperref}

% For program-code:
\usepackage{listings}
\lstloadlanguages{C++,make}
\newcommand{\Cpp}{\lstset{language=C++,keywordstyle=\bfseries,breaklines,breakindent=30pt}}
\newcommand{\Make}{\lstset{language=make}}
\newcommand{\inl}[1]{\lstinline$#1$}

\Cpp


\begin{document}

\author{Dilshad Sallo\\[1ex]
  Computer Science Department\\
  College of Science, Swansea University\\
  Swansea, SA2 8PP, UK\\[1ex]
  Student Number: 59950\\
  Under Supervision of Dr. Oliver Kullmann
}

\title{C++11 by Examples}

\maketitle



\begin{abstract}

C++11 is a new standard that released by C++ committee standard representing the effort of most experts in the world. This standard includes new features that addresses some limitations exist in traditional C++ as well as providing new features that never existed in any previous versions. These features are existed for supporting core language and some libraries as well as offering new facilities to make programming much easier and more functional.

The purpose of this project was to investigate core language and providing examples that represent cases of each feature to get most out of them, and demonstrating them as scientific catalogue to support programmers who have experience with programming in C++.

Investigating core language was achieved by investigating; firstly, features that have significant impact to improve the runtime performance, secondly, features that primary existed to enhance usability of language for easier learning and understanding. Finally, features that improve functionality of language and offers something extraordinary that never existed.

This investigating is done by presenting features that belong to these three types with nice examples that give programmers clear idea about functionality of these features  and encourage them to shift toward C++11 style.

\end{abstract}

% declaration
\begin{center}
\title \textbf{Declaration}
\end{center}

\textrm{This work has not previously been accepted in substance for any degree and is not being concurrently submitted in candidature for any degree.
\paragraph{}
This dissertation is the result of my own independent work/investigation, except where otherwise stated. Other sources are acknowledged by giving explicit references. A bibliography is appended.
\paragraph{}
I hereby give consent for my dissertation, if accepted, to be available for photocopying and for inter-library loan, and for the title and summary to be made available to outside organisations.}
\paragraph{}
\begin{flushleft}Signed ..................\end{flushleft} 
\begin{flushright}Date....................\end{flushright}                                                                                                                                               \clearpage


\begin{center}
\title \textbf{Acknowledgement}
\end{center}
\textrm{ First and foremost I want to gratefully and sincerely thank Almighty God for assisting me to complete this project. I owe special thanks to Dr. Oliver Kullmann for his excellent guidance, patience and most importantly, his friendship during doing this project.
\paragraph{} 
I would like to express special thanks to the Kurdistan Regional Government to fully support me during my study. I thank all my friends, my parents and all other family members for encouraging and supporting me throughout this study.
\paragraph{}
Finally, I give my deepest thanks to my wife Hanan for quiet patience and encouragement that make this work possible.}

\begin{flushright}
Dilshad H Sallo\\
599502\\
MSc Advanced Computer Science with specialisation in Software Technology\\
Swansea University\\
September 2012.
\end{flushright}

\tableofcontents


\chapter{Introduction}
\label{cha:intro}

XXX

\section{C++11}
\label{sec: C++11}

XXX

\section{Why C++?}
\label{sec: why C++}

XXX

\section{Why small and many programs?}
\label{sec:small and many programs}
knowing the syntax of C++11 language is not enough to learn and understand the correct way to use the language efficiently, unless providing  simple  programs that give idea to programmers from first glance.  These programs represent features of core language, which could also contain many cases. Providing small and many programs to represent these cases making the syntax of C++11 much easier to understand.

\section{A Brief History of C++}
\label{sec: History of C++}
The history of C++ programming language has begun in 1979, when Bjarne Stroustrup was working on his Ph.D thesis in the Computing Laboratory of Cambridge, University of England \cite{StroustrupHistory}. At that time, he had opportunity to work with a language called Simula, which was considered as the first language that supports the object-oriented language paradigm. He observed that Simula had very useful features for developing great software, but it was extremely slow in terms of practicality \cite{Stroustrup:2012:Cpp11}.

Shortly thereafter, Bjarne Stroustrup commenced working on a new language dubbed "C with Classes", which represented improvement version of C language. This enhancement was done by adding a number of new features that borrowed from the esoteric language Simula. The most notable of which were classes that have capability for supporting object-oriented programming \cite{StroustrupHistory}. 

During 1982, Bjarne Stroustrup found that "C with Classes" was not quite enough successful to become useful and attractive language that paid to develop organization \cite{StroustrupHistory}. Bjarne had only two options that must be taken regarding to C with Classes, either cease supporting this language, or use his experience with "C with Classes" to develop new language that able to develop and support lager organization \cite{Stroustrup:1994:DesignEvolution}.

In 1983, the name of the language was changed from "C with Classes" to C++. According to Bjarne \cite{Stroustrup:1994:DesignEvolution} the name of C++ was picked because it was short and had precise interpretations. In C, "++" operator is the C increment operator, indicating evolution from changes of C.  Around this time, a lot additional features were added to the language and the most known of which are references, constants(const), functions overloading and virtual functions.

In 1985, Stroustrup's reference to the language titled The C++ Programming Language was published. C++ was carried out as a commercial product in the same year though it was not officially standardized. The language was updated again in 1989 to include protected and static members, as well as multiple \cite{CplusplusHistoryofCpp}.

In 1990, the Annotated C++ Reference Manual was released, which became as basis for the future standard. At that time, many significant features were added to C++ included namespaces, new casts, exceptions, Boolean type and template \cite{StroustrupHistory}.

In 1998, the standardization of C++ published the first international standard for C++ under official title; Information Technology -- Programming Languages -- C++ \cite{Josuttis:2012:CppStandardLibrary}. This standard would be known as C++98 and has document number is ISO/IEC 14882:1998. The Annotated C++ Reference Manual has an important influence on the development of the standard.  In addition it was included the Standard Template Library which started its conceptual development in 1979 \cite{CplusplusHistoryofCpp}.  

Due to multiple problems and bugs have discovered in C++98, the standardization of C++ revised it accordingly, and release revision standard in 2003 to ensure greater portability and consistency, dubbed C++03, which has document number ISO/IEC 14882:2003 \cite{Josuttis:2012:CppStandardLibrary}.

In 2005, the standardization of C++ issued a Technical Report 1 that contains library extensions for the latest C++ standard \cite{Josuttis:2012:CppStandardLibrary}. The proposed changes for new standard was informally dubbed C++0x, which considered as working name for the next standard of C++. Its first draft for formal comments was produced in September 2008 \cite{CplusplusHistoryofCpp}. 

In 2011, C++0x was officially approved as C++11 and published as the second standard [C++ library ]. This standard has officially entitled as "Information Technology — Programming Languages — C++" and its document number is ISO/IEC 14882:2011 \cite{Josuttis:2012:CppStandardLibrary}.According to Bjarne \cite{Stroustrup:2012:Cpp11}, the 11 in the name of new standards refers to the year of publication that release in.

C++11 came with new features that have substantial improvement over the core language and library. C++11 provided new facilities that make life easier for programmers of all backgrounds as well as introducing new programming style  that make the language more easier to learn and understand.

% Boost 
\section{Boost C++ Libraries}
\label{sec: Boost}
The Boost C++ libraries are collection of libraries that created by the very same developers who designed and build the C++ standard libraries \cite{Schaling:2011:BoostCppLibraries}. They are designed to extend the functionality of C++ language in an efficient and commercial-grade, universally applicable style \cite{Boost:2007:Cpp} and they considered free and open source libraries \cite{Deitel:2012:CPP}.

Boost C++ libraries introduces helpful and well-designed libraries that regard compatible with C++ Standard Library \cite{Deitel:2012:CPP} and majority of which have been accepted in the C++ Standards Committee's Library Technical Report (TR1) \cite{Boost:2007:Cpp}.

In addition, parts of Boost library are currently being accepted into the Standard library for C++11 \cite{Boost:2007:Cpp} and they are regarded as one of the top libraries with a high industry acceptance. These libraries are Boost.Array, Boost.Bind, Boost.Function, Boost.Random, Boost.Regex, Boost.Smart\_ptr, Boost.Tuple and Boost.Type\_traits \cite{Deitel:2012:CPP}.

As a result, the current C++11 Standard libraries include several more Boost libraries in addition to those from TR1 and they provide many features that making Standard Library powerful and more effective in both industrial and educational fields.

% overview
\section{Overview}
\label{sec: Overview}
 
% chapter Tools
\chapter{Basic Tools for the Project Development}
\label{cha: tools}

XXX

\section{Git}
\label{sec: Git}
Git is “ a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency [website].”  Working with Git requires a server where it stores files and the meta-data for a project. However, this server is treated separately from Git.  Git is used to create database (repository) through server called Github that used to check the stages of existing files and give a control to a user to manage these data efficiently. Git offers simple way to track and deal with a collection of files through plenty command sets that give full access to internals. Git is available to install as a free version from  \url{http://git-scm.com/}.


\subsection{Command for using Git}
\label{subsec: Command for using Git}
Managing this project required some Git commands that made handling a source code much easier and more efficient. Here are as follows:

\textbf{Push} Push files and any changes related to the project  to a remote repository.
\begin{verbatim}
git push  [remote-name] [branch-name]
\end{verbatim}

\textbf{Fetch} Get files (the project) from a remote repository.
\begin{verbatim}
git fetch [remote-name]
\end{verbatim}

\textbf{Remote} It is used to add and delete a  references(short names) for remote Git repository . If "-v" option is included, it show all remotes that exists for this repository.
\begin{verbatim}
git remote [option]
git remote add [short-name] [url]
git remote rm [short-name]
\end{verbatim}

\textbf{Pull} pull and merge changes from individuals repositories to current branch.
\begin{verbatim}
git pull [remote-name] [branch-name]
\end{verbatim}

\textbf{GUI} Open a graphical commit tools in Git.
\begin{verbatim}
git gui
\end{verbatim}


\subsection{Git Gui}
\label{subsec: gitgui}
GUI is graphical tools that used for keeping track of changes that could be done to files in specific repository as well as used to visualize history of repository. When modifications over files have been done, a user must follow some instructions to deal with. Firstly, a user must go to git GUI and use scan to show those modifications ( ). Secondly, writing appropriate command to report the modification (). Thirdly, stage the modification (). Finally, commit the modification to be ready for pushing to repository (). Therefore, these steps must be taken by the user to handles any changes and making a history clear.


\subsection{Why is Git used?}
\label{subsec: why git}
Developing such the large project requires a great tool for managing source code efficiently as well as allowed other contributors to work on project simultaneously to being developed faster. Git offers such mechanism that making contributions possible on repositories. Therefore, Git is used by Dr.Kullmann and I to follow this project over period of allowed time. It was very helpful to me to get correction and guidance from Dr. Kullmann about what should I do to finish this project.

\section{Make Utility}
\label{sec: Make}
The traditional mechanics of compiling the source file into an executable file that used by several programmers could be useful, when program is fairly simple. However, the situation is not when a program contains a lot of small pieces of programs and need to be compiled because programmers face difficult to deal with modification of files when are done to fix the bug.

Handling many files need great tools that offer facilities to create executable file in such easy way as well as compiling only modified files instead of all source files.

The make utility is " a tool automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them " \cite{Stallman:2000:GnuMake}. Make is designed to allow programmers to efficiently compile large complex programs with many components easily. It provides mechanism to compile and turn source code into executable program with minimum effort. This is done by writing only "make" command in the UNIX shell.  

Make utility is especially helpful to manage and organizing projects that comprised of many source files and it reduces the probability of human error and difficulty of compilation.

\subsection{How does make work?}
\label{subsec: how make work}
In UNIX, when "make" command is typed; the operating system looks at file called "makefile" which residents in the directory of where programs reside. Makefile contains a series of directives and knowledge that tell "make" how to compile source files and in what order. 

Make goes through a makefile commencing with the target which going to create and it also looks at dependencies  of each target to find whether they are also considered as targets.  Make traces the chain of dependencies till it attains the end of the chain, at that time, it starts returning out to execute the commands that have been found in each target's rule. Building executable files by make, commences with building object files from the source files, and then links those objects files to create executable files. if any of source files is modified, the make utility compile only its object file and then linked into executable file, rather than recompiling all the source files. 

Therefore, running make utility is only possible if Makefile is provided within same directory and its contain all descriptions are required for directing make.

\subsection{Makefile}
\label{subsec: makefile}
Makefile contains full directive of the commands that used by make to decide how to build and execute the programs. It specifies the relationships between the component and target files of project by listing the needed files for each target file.

In general, Makefile contains at least basic components macros and rules and both are included in the Makefile that used in this project.

\begin{enumerate}
\item \textbf{Macro} Basically macro is a name or alias that is used to represent a string or instruction which could use frequently within the Makefile.  It is considered a very helpful way to simplify contains of Makefile.

Macro is defined in Makefile by a programmer through using (=) operator just like variables in C++. Convert a macro into its value in a target that is used for, require enclosing it within \$ ( ). However, there are internal macros that predefined in make to do specific purpose. These internal macros are very helpful to avoid code duplication.

Macros that used by programmer in Makefile for this project are:
\begin{verbatim}
CXX = g++ 
\end{verbatim}
Assign g++ compiler to macro called CXX to compile all C++ programs.

\begin{verbatim}
standard_options = -std=c++11 -Wall -pedantic
\end{verbatim}
Assign several options together such as (-Wall) that enable all warning during compiling process, and add the command-line parameter -std = c++11 to support C++11 features.

\begin{verbatim}
source_dir = .
\end{verbatim}
Assign directory, which used to find all files that have extension (such as cpp files)  to macro called source\_dir.

\begin{verbatim}
bin_dir = bin
\end{verbatim}
Assign directory called bin which contains all executable programs that produced by make, to macro called bin\_dir.

\begin{verbatim}
core_runtime = CoreLanguage/RunTime
core_functionality = CoreLanguage/FunctionalityImprovements
core_usability = CoreLanguage/UsabilityEnhancements
\end{verbatim}
Assign path of directories, to macros core\_runtime, core\_functionality and core\_usability.

\begin{verbatim}
compilation_units = $(wildcard $(source_dir)/*.cpp)
\end{verbatim}
Assign wildcard function that used to get a list of all cpp files from directories (core\_runtime, core\_functionality and core\_usability), to macro called compilation\_units.

\begin{verbatim}
source_files = $(notdir $(compilation_units))
\end{verbatim}
Assign notdir function that used extract all files from (compilation\_units) which contains all files to macro called source\_files.

\begin{verbatim}
programs = $(addprefix $(bin_dir)/, $(source_files:.cpp=))
\end{verbatim}
assign addprefix function that takes (source\_files:cpp) as a series of files and (bin\_dir) as directory to build lists of source files, to macro program.

\item \textbf{Rules} Rule is very crucial in make utility, since it tells make utility when and how to remake files. In general, its syntax looks like follows:
\begin{verbatim}
target ... : Prerequisites....
<tap>        command ...
             command ...
\end{verbatim}

\begin{enumerate}
\item \textbf{Targets} Targets are the core of what a Makefile does. They represent the name of required files that must be generated by a program such as executable or object files (see section executable). They can also represent the name of an action to accomplish for example "clean" (see section").

\item \textbf{Prerequisites} Prerequisites (also called dependence) are files that are used as input to generate the targets.

\item \textbf{Commands} Commands are action that will generate the targets from the prerequisites. The rule may contain more than command and each has its own line as showed above.
\end{enumerate}

Rules can be classified into explicit and implicit rules. 
\begin{enumerate}
\item \textbf{Explicit rules} are used to specify particular files as targets and prerequisites. In this type, a specific target will be updated whenever it is out of date, regarding to any of its prerequisites.

Explicit rules are used in our Makefile to do some purposes as follows:

\begin{verbatim}
.PHONY : all cleanall
\end{verbatim}
A phony is explicit target that used to avoid a conflict with a file of the same name, and to improve performance. Phony target is not really the name of file but it just use as recipe to be executed when there is an explicit request. By using phony target in this Makefile, make will run (all cleanall) regardless of whether there are files named (all cleanall).

\begin{verbatim}
cleanall :
\end{verbatim}
cleanall is explicit target that used to delete all the object files and executable files but here it defined in the beginning as phony target.

\item \textbf{Implicit rules} are general rule that tell make utility when and how to build files that has specific file extensions. Implicit rules begin with either a period or path and can be either suffix rules or pattern rules. Suffix rules are built into make and used as default rules to deal with C language.  Pattern rules are defined by using \% character and are used for matching common targets and prerequisites. They also built into make.

Implicit rules are used in our Makefile to achieve specific purpose:

\begin{verbatim}
.SUFFIXES :
\end{verbatim}

this used to delete all defaults suffix rules, and allowing us to define new rules that deal with C++ language.

\begin{verbatim}
$(programs) : $(bin_dir)/% : %.cpp
\end{verbatim}
Pattern rules are used for match specific files. Thus, we build our pattern rules which take any cpp file (\% .cpp) and put it in bin\_dir, and assign them to \$(programs). 

\end{enumerate}
\end{enumerate}


% chapter Core Language Runtime Performance Enhancements
\chapter{Core Language Runtime Performance Enhancements}
\label{chapter: Runtime Performance Enhancements}

XXX

\section{Rvalue references}
\label{section: Rvalue references}
A reference in C++ is an alias or alternative name for an existing object, and any modification could be done through this reference, will affect the original. Traditional C++ supports lvalue references, which are used to reference to lvalues. L values can be represented by single variable or persistent object that located on the left-hand side of an assignment operator. All variables, including (const) variables are Ivalue \cite{Gregorie:professionalcpp}.


On the other hand, rvalue defined as anything is not lvalue, such as temporary object and constant value that appeared on the right- hand side of an assignment operator.  Lvalues can be used as rvalues, but not vice versa \cite{Gregorie:professionalcpp}.


In traditional C++, non-const references can bind to lvalues, and const references can bind to either lvalues or rvalues. However, there is nothing that can bind to a non-const rvalue. Thus, a reference to a temporary and a constant are not supported in traditional C++ \cite{Stroustrup:2012:Cpp11}.


C++11 brings new concept called an rvalue reference, which bind only to rvalues but not to lvalues. Rvalue references use two ampersands (\&\&) rather than one (\&), and can be const and non-const \ref{RvalueReference_Basic}, the same as lvalue references \cite{Gregorie:professionalcpp}.


Rvalue references can be used as a parameter to function by using two ampersands as part of the parameter specification such as type \&\& name. Then, this function can be invoked when a parameter is a temporary object or constant value. Otherwise, function that takes lvalue references will be invoked by lvalue \ref{RvalueReference_Parameter}.


However, while rvalue reference will never be bound to an lvalue, it is possible by a programmer to force a compiler to convert an lvalue into an rvalue. This can be done by using new feature called std::move (), which added by C++11 \ref{RvalueReference_Move} \cite{Gregorie:professionalcpp}.


Rvalue can also be used as a parameter to a function template but with nuance in terms of implementation. Calling the function with rvalue, leading the type parameter is deduced to be value. However, if an lvalue is passed to the function, then the type parameter is deduced to be an lvalue reference. Due to the function parameter is declared as rvalue reference (type \&\& name), that is, it treats as a reference to a reference for original reference type. Thus, a single function is able to accept both rvalue and lvalue parameters \ref{RvalueReference_Template} \cite{Williams:2012:CCA}.


This is pretty useful to execute perfect forwarding, which means that a function template able to pass its arguments by to another functions while keeping the rvalue and lvalue nature of the function arguments.  This avoids excessive copying and avoids the template author having to write multiple overloads for rvalue and lvalue references. Therefore, this concept is essential for library features such as std::thread and std::function which pass arguments to another function \ref{RvalueReference_Forwarding} \cite{Williams:2012:CCA}.


One of the main reasons for introducing the rvalue reference is to implement move semantics, the next topic in this chapter.

% Move semantic
\section{Move semantic}
\label{section: Move semantic}
C++ is always used to create fast and robust programs that be trusted in different areas.  However, one of the cases that lead to slow down performance of many C++ programs is the creation of temporary objects.


Usually, these temporary objects are created by copy constructor and assignment operator because a second object should be equal to the original to accomplish operation; therefore, once the operation is done a program has two objects with the same value that resulting in expensive object copies \cite{Stroustrup:2005:Cpp}.


C++11 introduces the concept of move semantic, which allows an object to be implemented by a move constructor and a move assignment operator. These functions are used by a compiler when the second object is temporary object and is going to be destroyed after the copy or assignment. Both the move constructor and the move assignment operator transfers resources such as variables and pointers from the source object that is temporary object, to the new object (target object) and then reset the variables and pointers of the source object to null values. This would be similar to moving a file from one directory to another. By doing this, the ownership of the memory will be move from the source object (temporary object) to the new object (target object).


In fact, move constructor and move assignment operator do a shallow copy of the resources and switch ownership of allocated memory to prevent memory leaks or dangling pointers \cite{Gregorie:professionalcpp}.


Thus, move semantic is a significant concept to increase the performance of programs by avoiding unnecessary copies that used in temporary objects.


The implementation of move semantics is supported by rvalue references, which should be added to class to implement move constructor and move assignment operator.


Move constructor is pretty useful, and its purpose is to steal as many resources as it can from the original object, as fast as possible, because the original does not need to have a meaningful value any more, because it is going to be destroyed. 


Move constructor can be tested with class C that contains move constructor \ref{MoveSemantic_Constructor}. If move constructor exists, it will be used by a compiler to move the objects instead of copy them and without needing for any deep copy \cite{MSDN:2012:CppModern}. The move constructor will be invoked by a vector to move old vector to the new one and bigger vector. The output of class C will be as follows:

\begin{enumerate}
\item Constructor called.
\item Move constructor called.
\item Constructor called.
\item Move constructor called.
\item Move constructor called.
\end{enumerate}

In the beginning, the vector is created and still empty, until first line of code will be executed:
\begin{center}
v.push\_back(C(10));
\end{center} 

Then, a new C object is created by invoking the normal constructor (1); after that, a vector will resize itself to accommodate a new object, which is going to push in. The C object that created will move into the vector by calling the move constructor (2). When the second line of code is executed:
\begin{center}
v.push\_back(C(20));
\end{center}

A second C object is also created by calling the normal constructor (3). At this point, the vector can store one element, so once again it is resized to accommodate a second object. When the resizing is done by the vector, the objects that previously have added require to be moved from the old vector to the new and larger vector, so this will require invoking the move constructor for objects that previously have added (4). And then, the new C object is moved into the vector by invoke move constructor (5). As a result, the move semantics is efficiently performed the insertion operation for vector by moving the elements rather than copying them \cite{MSDN:2012:CppModern}.


The move assignment operator can also be tested by another class C \ref{MoveSemantic_AssignmentOperator}, which has function called createObject() that create temporary C object ( as a return type is always rvalue) and assign it to another object called c1  (c1 = createObject()), resulting to invoke the move assignment operator. The move assignment operator is also invoked by using std::move () (which converts from lvalue to rvalue) to assign one object that consider temporary object to a target object \ref{MoveSemantic_AssignmentOperator} \cite{MSDN:2012:CppModern}.

On the other hand, the assignment (c3 = c1) will invoke the copy assignment operator because the object c1 is not temporary object, but a named object.


Another situation that uses move semantic to increase the performance, when swap of elements are required. This can be done by using std::move (), which is the C++11 way to use move semantics explicitly and can be used to transfer the content of an object somewhere else, without doing a copy. This will lead to raise the performance of programs that require a lot of swaps \ref{MoveSemantic_Swap} \cite{Gregorie:professionalcpp}.


% Generalized constant expressions
\section{Generalized constant expressions}
\label{section: Generalized constant expressions}
C++ had the notion of constant expressions such as 1+2, that always yield the same results at compile-time and at run-time. Such these expressions are improvement opportunities for a compiler to execute them at compile-time and gain the results in a program rapidly. Constant expressions required in some circumstance that should meet C++ specification, including enumeration values and specifying the bounds of an array. Currently, they can be expressed in C++ by using the keyword const, which could appear with variables, indicating that cannot be altered.


However, the C++ rules concerning constant expressions are overly restrictive. They obligate some usage such as macros or template meta-programming instead of inline functions to guarantee the compile-time evaluation of constant expressions. This could happen when using, for example, std::numeric\_limit$<>$:: max  class template.  Seemingly, they should be used as an integral constant but in fact it is functionally equivalent to the macro INT\_MAX. Thus, they are not integral constant. This encourages users to favour macros when values require to be known at compile time.


Another restriction could be found in C++, when return type of function is used for specifying the bounds of an array. This causes compilation error because a compiler has no way of knowing the return function will be constant at runtime \cite{Stroustrup:2012:Cpp11}. 


Due to these restriction, C++11 has extended the constant expressions by introducing the constexpr keyword that dubbed generalized constant expression. The constexpr keyword allows certain computations happen at compile-time instead of run-time, when the program itself is run.  This has apparent benefit in terms of performance, due to anything could be done at a compiler-time, will be done once, and instead of every time the program runs. Hence, a program takes the advantage of compile-time, and leading to increase performance of a program \cite{Williams:2012:CCA}.

\subsection{Constant-expression data}
\label{subsection: constant-expression data}
The constexpr keyword can be applied to variables and data members.  Variables or data members that are declared with this keyword are named a constant-expression value, and they only allowed initializing with constant expressions. Variables and data members that declared with constexpr keyword have the same behaviour as if they were declared const. However, there is one difference namely, they need initialization before they are used and should be a constant-expression to guarantee that constexpr variables and data members can always be used as a constant expression \ref{Constexpr_Data} \cite{Williams:2012:CCA}.


\subsection{Constant Expression Functions}
\label{Constant Expression Functions}
A constant expression function is a function that can be performed at compile time by means of inlining and assessing the result at compile-time. Declaring a function as constexpr enforces a few requirements that must be followed regarding as a constant-expression function; otherwise, declaring it constexpr is a compilation error.  The requirement necessary for a constexpr function are as follows:

\begin{enumerate}
\item The body of function must consist of single return statement and must be in form {return expression ;} where expression must evaluate to a constant expression after substitution.

\item Any parameters to the function must be a literal type or reference to literal type.

\item The return type of function must be a literal type. It cannot be void.

\item Function can call only other constexpr functions \ref{Constexpr_Recursion}.

\item If the constexpr function is defined as member of a class, the function cannot be virtual.
\end{enumerate}

Applying these requirement enable a compiler to evaluate a constexpr function at compile time. Thus, it becomes possible to use the return type of constexpr function to specifying the size of an array \ref{Constexpr_ArraySize} \cite{Gregorie:professionalcpp}.

However, recursion in this type of function is not restricted. It can be applied by using the ternary operator (? :) as a single return statement. Hence, a compiler can optimize away the call and make the computation all at runtime. In this case, by permitting more complex computation, constexpr acts differently than a just in-line function, because an inline recursive function is not possible, lead to consider function argument is itself a constexpr and be computed at compile time \ref{Constexpr_Recursion} \cite{Allain:2011:FutureCpp}.


Constexpr function can also be involved at runtime. This can be done when the arguments to the function are declared as non-constant. Therefore, there is not required for creating separate functions to be executed at compile time and run time as long as it offers a convenient way to define function that work at compile time as well as runtime \ref{Constexpr_FunctionRuntime} \cite{Allain:2011:FutureCpp}.

\subsection{Constant Expression Constructors}
\label{subsection: Constant Expression Constructors}
A constant expression constructor allows creating user-defined types (such class) as constant expression. This can be done by defining a constructor with constexpr keyword. Defining constexpr constructor must also meet following criteria:

\begin{enumerate}
\item	The body of constructor must be empty.
\item	All arguments of constructor must be literal types or references to literal types.
\item   All non-static data member must be initialized.
\item	The body of constructor cannot be a function-try-block.
\item	All data members must be initialized with constant expressions.
\end{enumerate}

The constant expression evaluation happens in the member initializations which must fit the requirement (arguments must be constants) to evaluate as constants. An object that construct with a constant-expression constructor and constant expression arguments, is named as user-defined literal. Thus, it can be used at compile time \ref{Constexpr_ConstantConstructor} \cite{Gregorie:professionalcpp}.


As a result, the constexpr improve type-safety and portability for code requiring compile time evaluation, which can be pretty useful for supporting generic programming and library building.

% modification of the definition of POD
\section{Modification of the definition of plain old data}
\label{section: Modification of the definition of plain old data}
Plain old data (POD) is a data structure that represented with fundamental types, without using the object oriented features, to suggest areas of essential compatibility between comparable data types in C and C++.


A POD type in C++ is classified as either a scalar type or a POD class. The scalar type collectively refers to the fundamental types of C++ such integral types (int, char), floating types (float, double), enumeration types and pointer types. Whereas the POD class has no non-static data (including arrays) of any pointer-to-member type, no non-static data (including arrays) of any non-POD class type, no user-defined copy assignment operator, nor user-defined destructor.


In addition, a POD class has to be an aggregate, meaning it has no private or protected not static data members, no user-declared constructors, no base classes and no virtual functions \cite{Kalev:1999:ACP}.


Therefore, in the traditional C++, the actual definition of POD is based on a set of restrictions that should be satisfied for defining POD class or structure, otherwise, it is not POD type. As a result, C++ able to distinguish between POD types and non-POD types. However, in some situations, this distinction is limited, because some non-POD types have similar properties as POD types. Thus, they have the same behaviour.


C++11 relaxed some of the POD rules by dividing the POD concept into new type categories: trivial classes and standard layout classes and their definition no longer depends on the definition of aggregate \cite{MSDN:2012:CppModern}.


A trivial class can be statically initialized and can be copied via memcpy, instead of having to use a copy constructor. The lifetime of a trivial type begins when its storage is defined, not when a constructor completes. The trivial class is a class that:

\begin{enumerate}
\item	Has a trivial default constructor. 
\item	Has a trivial copy and move constructor.
\item	Has a trivial copy and move assignment operator.
\item	Has a trivial destructor.
\end{enumerate}

Additionally, trivial class has no virtual member functions of the class and no virtual base classes. Hence, it can have user-defined constructors as long as above requirements are available \ref{POD_TrivialClass} \cite{ISO:2011:Cpplanguage}.

Standard layout is intended to capture the first intent by creating something with a layout the same as getting in C. A standard layout class is a class that:

\begin{enumerate}
\item	Has no virtual functions and no virtual base classes.
\item	Has no non-static data members of type non-standard-layout class (or array of such types) or reference.
\item	All its non-static data members have the same access control (public, private, protected).
\item	It has no base classes of the same type as the first defined non-static data member \ref{POD_StandardLayoutClass}.
\end{enumerate}

A class or structure is considered POD type if it is trivial, standard-layout, and all of its non-static data members and base classes are PODs \ref{POD_StandardLayoutandTrivialClass} \cite {ISO:2011:Cpplanguage}.


By separating trivial and standard-layout concepts, it becomes possible to give up one without omitting other. A class that has copy  and move constructors could not be trivial, but it may be may be standard-layout and hence interrupt with C. Likewise, a class that has  public and private non-static data members may not be standard-layout, but it could be trivial and hence, can be copied via memcpy.


\section{Summary}
\label{sec: Summary}


% chapter Core Language Usability Enhancements
\chapter{Core Language Usability Enhancements}
\label{chapter: Usability Enhancements}
XXX

\section{Uniform initialization}
\label{section:Uniform initialization}
C++ provides various ways to initialize objects (built-in types and user-defined types) depending on their types and the initialization context. Fundamental types such as variables and pointers can be initialized by using the equal sign. Initialization of data members in classes, which have user-defined constructor require a constructor's member initialization list for their data members, and initialization of objects are included in parentheses in the objects declaration. Finally, Initialization of aggregates types require braces, except string literals that may also need a pair of double quotes to be initialized. Meaning that there is no general way to initialize every type exists in C++ \cite{Stroustrup:2012:Cpp11}


Therefore, It is difficult for ordinary programmers to remember the rules for initialization and to choose the appropriate way according to data types, because when misused could leads to the error messages vague.


In addition, there is no proper way to initialize arrays that are member of a class, nor dynamically allocated arrays. And finally, there is no convenient form to initialize the elements of a Standard Library container \cite{Stroustrup:2012:Cpp11}.


C++11 introduces a universal initialization notations { }, called brace-initialization, which is used to address the problems of initialization in traditional C++. Brace-initialization can be used to initialize every types in the same way, whether built-in types or user-defined types (that is, class objects), and using equal sign to accomplish the initialization is considered optional. Usage of Brace-initialization offers new facilities that make initialization of objects easier and more efficient as well as making code shorter and obvious \cite{Reddy:2011:API}.


Brace-initialization is used to initialize all build-in -types including variables, strings and pointers and this initialization can be applied directly to the class members. Additionally, default initialization is applied when pair of braces is empty such as variables initialize to zero and pointers to null \ref{UniformInitialization_ClassMembers} \cite{Reddy:2011:API}. It can also be used to initialize arrays that are members of a class via the constructor initializer \ref{UniformInitialization_Array}.


Brace-initialization is not only limited to these cases, but also it is applied with new expressions to initialize dynamically allocated arrays directly when arrays are declared \ref{UniformInitialization_DynamicArray} \cite{Reddy:2011:API}.

Notion of brace-Initialization is pretty useful in terms of class objects; it provides efficient and easy way to initialize the objects by replacing parenthesized list with brace-Initialization and then invoking a constructor to achieve that. Moreover, initializing object return can be achieved implicitly by using this notion \ref{UniformInitialization_ObjectReturn} \cite{Gregorie:professionalcpp}.


In traditional C++, narrowing can be performed implicitly, for example, assigning a double value to integer value is possible. However, using brace- initialization provides protection against narrowing, and doing such assigning above causes compiler error, because this type of conversions is disallowed to accomplish by a compiler \ref{UniformInitialization_Narrowing} \cite{Gregorie:professionalcpp}.


The notion of uniform initialization can be effectively used to initialize the Standard Library containers and user-defined constructors. This can be done via a new template class that added by C++11 called std::initializer\_list, the next topic in this chapter.


% Initializer lists
\section{Initializer lists}
\label{section: Initializer lists}
C++ has partial support for initializer lists that can be applied for simple aggregate data types such C-style arrays and structs. However, this concept cannot be used to initialize classes that have user-defined constructors. Furthermore, Standard library containers are not allowed to be initialized by using this partial initialize lists \cite{Reddy:2011:API}.


C++11 extends initializer lists that can work perfectly with all classes that have user-defined constructors \ref{InitializerList_Constructor}. This can be done via new template class called std::initializer\_list, which is a part of $<$initializer\_list$>$ header file.


This class in somehow associated with uniform initialization when they use to initialize container classes, because Standard Library classes in C++11 have been updated with a new constructor type called std::initializer\_list.


When a compiler finds a declaration with an initialization similar to this form \{1, 2, 3, 4\}, it looks for a constructor that receives std::initializer\_list as argument. If it is found, the compiler will create an instance of the initializer\_list class with the arguments inside the brace-initialization and then, will invoke the constructor found \ref{InitializerList_Vector} \cite{Reddy:2011:API}. 


The initializer lists can be also used explicitly with function, which take it as a single argument and then can be invoked by uniform initialization to do specific purpose \ref{InitializerList_Function} \cite{Reddy:2011:API}.


% Auto keyword
\section{Type inference - Auto keyword}
\label{section: Auto keyword}
Many programming languages such Java, C and traditional C++ obligate a programmer to specify data type of variables before initializing and using them in a program. However, with the advent of template types and meta-programming techniques, type names become extremely long and complicated, especially, determining return value of function that used with template classes or using specified names for iterators combined with template classes \cite{Horstmann:2008:BC}.


In these cases, the data types required for these declarations become complex, ambiguous, and cannot be easily determined by an ordinary programmer.


C++11 adds significant feature to type inferences called auto keyword, which deduce variable types automatically based on the initializer expression at compile-time.  The auto keyword considers one of the most important features that added to C++11 due to its role to make programming easier to write and understand as well as improving generic programming \cite{Gregorie:professionalcpp}.


The keyword auto can be used in place of a data type to define build-in types such as int, long and etc, depending on initialization expressions \ref{AutoKeyword_Variable}. It can also be used with const and volatile qualifiers to define const and volatile pointer \ref{AutoKeyword_ConstVolatile}. Additionally, direct initialization syntax with new expressions is permitted by using auto keyword, for instance, the expression auto(1.2) has type double, and thus, new auto(1.2) has type double*. Combination of both will give, auto* d = new auto (1.2). And here, new auto (1.2) has type double*, which will be type of d as well \ref{AutoKeyword_NewExpression} \cite{Stroustrup:2012:Cpp11}.

In many cases, C++ programmers could use some exotic types such as function that return pointer to pointer, and could be hard to determine the return type properly, particularly, when it used with template classes. The auto keyword can be placed in such situation, to let compiler to deduce the data type that is returned from function and making a code easier to write and understand \ref{AutoKeyword_Function} \cite{Overland:2011:CWF}.


Using auto keyword to infer the type of a variable from initialization is most useful when that type is either difficult to know exactly or difficult to write by a programmer. Suppose a programmer has a map container that maps string to a vector of unsigned an integer as follows: 

\begin{center}
std::map$<$std::string,std::vector$<$unsigned int$>>$ mv;
\end{center}

With traditional C++, if a programmer wanted a constant iterator to the beginning of this map, code will be likely as follows:

\begin{center}
std::map$<$std::string, std::vector<unsigned int$>>$::const\_iterator iter = mv.begin();
\end{center}

However, the auto keyword can be placed instead of this complicated and long type to achieve the same purpose. Additionally, it makes code easier to understand and save a programmer's time, as follows:

\begin{center}
auto iter = mv.begin();
\end{center}

Code of achieving that can be shorter and more robust when a programmer use auto keyword within range-based for statement (which added by C++11), instead of for loop to accomplish the same result \ref{AutoKeyword_MapContainer}. The auto keyword can also be placed instead of class template std::initializer\_list (which added by C++11), to declare an object of the same type in easy way \ref{AutoKeyword_InitializerList} \cite{Gregorie:professionalcpp}.


The use of keyword has significant role to support generic programming, particularly, template classes. It deduce the type of a variable  during compile- time that depends critically on template argument in such easy way that could not be figure out by a programmer \ref{AutoKeyword_Template} \cite{Stroustrup:2012:Cpp11}.


The auto keyword has another different usage when it appears with alternative function syntax, which added by C++11. It indicates that function prototype is using alternative function syntax \ref{AlternativeFunction_Syntax}. It could also be served as a place holder for the return type that is deduced or provided later by the alternative function syntax \ref{AlternativeFunction_Template} \cite{Prata:2012:Cpp}.


The auto keyword is widely used with lambda function, which also added by C++11. As return type of lambda functions is not specified int many cases, the auto keyword uses to deduce return type of function properly, depending on expression that used as return type \ref{Lambda_ImplicitReturn} \cite{Gregorie:professionalcpp}.

% Decltype
\section{Type inference – Decltype keyword}
\label{section: Decltype keyword}
C++11 introduces another new type inference called decltype (declared type), which is used to determine the type of an expression at compile-time. The decltype keyword takes as argument an expression, and returns the type associated with that expression \cite{Stroustrup:2012:Cpp11}. 


The decltype keyword can be used to create different data types depending on an expression that has been used as argument.  If expression is a variable without parenthesized, then the data type will be the same as the expression type \ref{DecltypeKeyword_Variable}. If expression is lvalue (which mean that variable with parenthesized), then the data type will be a reference to that expression type \ref{DecltypeKeyword_lvalue}. Finally, if expression is function call, the data type will be the same as function return type \ref{DecltypeKeyword_Function} \cite{Prata:2012:Cpp}.


The decltype keyword is pretty useful to deduce type for combination of expressions that could not known by a programmer. This could happen in generic programming, particularly, template classes because the data type is not defined until compile-time. Thus, the decltype keyword allows compiler to go through a check-list to determine the type of expression \ref{DecltypeKeyword_Template} \cite{Stroustrup:2012:Cpp11}.


The benefit of decltype keyword can also be shown, when it uses as return type for alternative function syntax (which added by C++11) because a return type is not specified in this type of function within templates. Thus, decltype is used as return type to deduce the type from the context of expression \ref{AlternativeFunction_Template} \cite{Gregorie:professionalcpp}. 

% alternative function
\section{Alternative function syntax}
\label{section: Alternative function syntax}
A function syntax that was designed for C language, is yet using by traditional C++. This old syntax raises some problems and cannot be quite enough for new functionality that has been added to C++11, including deducing return type in the context of declaration \cite{Gregorie:professionalcpp}.


C++11 introduces a new syntax for declaring functions using a different method to the one that is traditional in C and C++. This notation is known as alternative function syntax, and involves placing the return type at the end of the function signature instead of at the start. Additionally, the auto keyword is placed at the start for the name of the return type, indicating that the prototype is using the alternative function syntax \ref{AlternativeFunction_Syntax} \cite{Gregorie:professionalcpp}.


Alternative function syntax can be used with decltype keyword to use "this pointer”, which is not otherwise allowed. This is pretty useful with Standard Library container such as vector, to return the first and last value that is pointed by this pointer \ref{AlternativeFunction_This} \cite{ISO:2011:Cpplanguage}. 


Moreover, using the combination of alternative function syntax and the decltype keyword within templates, solve important problems that could face a programmer, particularly, when a return type is not known exactly.  Consider this situation, when template has two different types, and return type will be the combination of these types, as following:
\begin{center}
template $<$class T1, class T2$>$  ?type? add (T x, U y) 


\{ return x+y; \}
\end{center}

As it is shown, a type of adding x and y are not known in advance by a programmer. Using the decltype (x + y) alone for return type to address this issue, will cause compiler error, because x and y at the beginning of prototype, are not known.  In other words, they are not in scope, as follows:

\begin{center}
template $<$class T1, class T2$>$  decltype( x + y ) add(T x, U y)


\{ return x+y; \}
\end{center}

The benefit of alternative function syntax can be gained here by allowing the return type (decltype(x + y)) is specified after the parameter list. Hence, x and y are in the scope and can be used by decltype to deduce return type \ref{AlternativeFunction_Template}. As a result, alternative function syntax and decltype keyword are very useful in the context of specifying the return type of template functions, when a return type is not well known by a programmer\cite{Prata:2012:Cpp}.


alternative function syntax is not mainly about templates and type deduction, but also about the scope.  With this new syntax, when the scope is written to define function within class, there is no need to add it again to return type because return type goes at the end of the function. Thus, a compiler can reach the return value as it already knows the function is part of class \ref{AlternativeFunction_Scope} \cite{Allain:2011:FutureCpp}.

% Range-based for statement
\section{Range-based for statement}
\label{section: Range-based for statement}
C++ supports three types of looping structures namely while loop, do while loop and for loop. In some cases, such iterating over the elements of Standard Library containers including vector and map requires a lot of codes to accomplish iteration properly. Because using these types require create a new variable to store the iterators, and then dereference the iterators using the * operator to get the actual value, as well as initializing the beginning and ending conditions in these forms of loops \cite{Horstmann:2008:BC}.


C++11 adds a fourth way of looping called the range-based for statement that allows for easy iteration over elements of a list. Range based-for statement is useful technique for writing less code and getting less errors, and can be used with C-style arrays \ref{RangeFor_Array}, initializer lists \ref{RangeFor_InitializerList} and Standard Library containers, that have begin () and end () functions such vector \ref{RangeFor_Vector}. 


Range based-for statement is much easier to read and understand, and saves programming effort because it does not require initialize the beginning and ending conditions \cite{Overland:2011:CWF}.


Generally, Range based – for statement comes in two forms: first one is:
\begin{center}
For (base\_type  variable : container)
\end{center} 

This is used to deal with elements of list by value. Thus, the contents of a list cannot be modified \ref{RangeFor_InitializerList}. The second one is:
\begin{center}
For: (base\_type\& variable: container).
\end{center}

This uses reference to be able for modifying the contents of list \ref{RangeFor_Array}.


The range-based for statement also supports the notion of uniform initialization, for instance, a programmer can simply print a lot of numbers by using this form of loop with brace-initialization. \ref{RangeFor_UniformInitialization} \cite{Overland:2011:CWF}.

% Lambda Expression
\section{Lambda Expressions}
\label{section: Lambda Expressions}
Traditional C++ includes useful generic functions such as std::for\_each and std::transform, which can be very handy to deal with Standard Library algorithms.  Unfortunately, they can also be quite cumbersome to use, particularly if a functor (functors also called function object, are objects that can be handled though they are a function or function pointer, they are declared by defining member function operator () in class), that would be used as predicates for STL algorithms, are unique to the particular function, because using functor once in specific place seems overkill to be writing whole class just do something trivial and one off \cite{Allain:2011:FutureCpp}. 


Another reason is that, the function that used by C++ programmers, has C style that  allow each function name to do specific purpose in a program, meaning it must be written separately for each various usage.


C++11 introduces a new feature called lambda expression (also known as a lambda function) that can be created almost everywhere. Lambda expression considers one of the most exciting features due to its ability to create anonymous functions inline in a source code and greatly simplify it, rather than writing a separate function or a function object.  Thus, the ability of creation functions become quicker and easier, and the code can be easily understood \cite{Gregorie:professionalcpp}.


This notion may seem a bit weird to those only familiar with the C family of languages, but this is a fairly common feature of most programming languages such as C\#, PHP, JavaScript and Haskell.  


The syntax of lambda expression can be demonstrated in different styles, depending on purpose that should be achieved. Basically, the general syntax is as follows:
\begin{center}
[capture\_block](parameters) mutable exception\_specification -$>$ return\_type {body}
\end{center}

A lambda expression contains the following parts:
\begin{enumerate}
\item \textbf{Capture block:} this determines how variables (from outside-global variable or inside-local variable) are captured from the enclosing scope, and then make them being available to use inside the function body. there are two methods for capturing all variables from enclosing scope:

      \begin{enumerate}
      \item $[$=$]$ means that a compiler captures all variables by value \ref{Lambda_Mutable}.
      \item $[$\&$]$ means that a compiler captures all variables by reference 
             \ref{Lambda_FunctionParameter}.
      \end{enumerate}
      However, leaving the capture block empty [], tells a compiler not to capture nothing from the enclosing scope \ref{Lambda_Invocation}. \\
      It is also possible to capture variables using both reference and value. This can be done by selectively determine which variables are being captured by reference and then using $[$\&$]$ in front of them. Then, the rest are being captured by value $[$=$]$ as a default capture \cite{Gregorie:professionalcpp}.The default capture must be the first element in the capture list as follow:
      \begin{enumerate}
      \item $[$=, \&a, \&b$]$, capture a and b by reference and the rest by value by default \ref{Lambda_Foreach}.
      \item $[$\&, a$]$, capture by reference by default, except a by value.
      \end{enumerate}
      
      
\item \textbf{Parameters:} : It can be represented by a list of parameters that are used for the lambda expression \ref{Lambda_ExplicitReturn}. This list is optional and can be omitted, if a programmer does not need any parameters for the lambda expression and not specify mutable, nor exception specification and return type \ref{Lambda_Invocation}. The list of parameters in the lambda expression is similar to that in the normal functions, except some restrictions including parameters cannot have default values, unnamed parameters are not allowed and variable length argument lists are not allowed \cite{Cppreference:2012:Cpp11}.

\item \textbf{Mutable:} When variables from the enclosing scope are captured by value, a copy of which will become available inside the lambda expression. By default, those copies are considered as const copies, meaning lambda body cannot modify the value of those copies. If mutable option is inserted to the lambda expression, those copies are become non-const and then can be modified \ref{Lambda_Mutable} \cite{Cppreference:2012:Cpp11}.

\item \textbf{Exception\_specification:} This is optional and uses to determine which exceptions can be thrown by the body of the lambda expression.

\item \textbf{Return\_type:} It is used to specify the type of the returned value such as std::string \ref{Lambda_ExplicitReturn}. This is optional, and If it is not provided, a compiler will decide implicitly the return type according to expression that used for return type \ref{Lambda_ImplicitReturn}, otherwise the return type is considered void \ref{Lambda_Invocation} \cite{Cppreference:2012:Cpp11}.
\end{enumerate}

As a result, a program may not include all these options because they are primarily dependent on a programmer's intend to accomplish specific purpose.


The lambda expression can be used to print simple string without having any parameters and return type. This can be achieved by parentheses () at the end of the lambda body, which causes to execute the lambda expression immediately \ref{Lambda_Invocation}. It is also possible to store pointer to lambda expression and execute it by the function pointer \ref{Lambda_PointerFunction} \cite{Gregorie:professionalcpp}.


\subsection{Lambda Expressions as Return Type}
\label{subsection: Lambda Expressions as Return Type}
Std::function$<>$ class template, defined in the <functional>, is polymorphic function object wrapper and is considered one of the great new features that introduced by C++11, due to its ability to wrap to callable objects ( function pointers, function object and lambdas) as long as there is compatibility in terms of argument  and return type with those of the wrapper.


Therefore, the new std::function is an extremely useful way for passing around lambda functions as return values and by doing that, lambda expressions can be returned from ordinary functions. \ref{Lambda_FunctionReturnType} \cite {Josuttis:2012:CppStandard Library}.


\subsection{Lambda Expressions as Parameters}
\label{subsection: Lambda Expressions as Parameters}
The std::function can be also used to pass around lambda expression as parameters. Thus, it is possible to defining ordinary functions that take lambda expression as parameter to implement callback functions \ref{Lambda_FunctionParameter} \cite{Allain:2011:FutureCpp}.


Using lambda expression as parameters has significant impact over Standard Library algorithm and without doubt, it is the biggest beneficiaries of lambda expressions, because previously, using algorithms such as std::sort and std::for\_each require writing separate code to accomplish their purposes. But now, lambda can be placed as third parameter to achieve the same purpose, without writing separate functions \ref{Lambda_Foreach}, \ref{Lambda_Sort} \cite {Gregorie:professionalcpp}.


As a result, lambda expression is significant step forward, and improves code clarity and makes programming easier.

% Delegating Constructors
\section{Delegating constructors}
\label{section: Delegating constructors}
C++ does not furnish a mechanism by which one constructor is able to delegate another constructor in the same class.  As a consequence, the default arguments cannot be used by class's constructor (s) for initializing class members. Therefore, classes should provide multiple constructors, each with a distinct parameter(s). Those constructors may often execute similar initialization operations, and this leads to force a programmer to duplicate same pieces of code in each constructor as well as duplication in object level \cite{Overland:2011:CWF}.


In addition to that, Other Object Oriented languages, such as Java, permit constructor to delegate another of the class's constructor(s).  As Java is often used as educational and basic language, increasing C++ newcomers with prior experience of Java are often find substantial differences between these languages. Hence, huge mistake could happen when attempting to write C++ code as same as Java's behaviour \cite{Overland:2011:CWF}.


C++11 provide mechanism of delegating constructor, which permit constructor to call another constructor from the same class. This feature allows a programmer to define general and desirable initializations in one constructor dubbed target constructor, which can be called by delegating constructor to do the initialization. Delegating and target constructor are presented in the same interface as other constructors do. Target constructors do not require particular treating to become the target of a delegating constructor. In fact, they are chosen by overload resolution \cite{Overland:2011:CWF}.


When the execution of target constructor is completed, controls get back to the delegating constructor. A delegating constructor can also be used as the target constructor for one or more delegating constructors but a programmer should be aware about a recursive chain of delegation which could lead to compiler error \cite{Overland:2011:CWF}.


Delegating constructors makes writing overloaded constructors easier and without duplicating the common code. It also makes programs more readable and maintainable that may lead to decrease the chance of error \ref{DelegatingConstructor} \cite{Overland:2011:CWF}.

% Override keyword
\section{Override keyword}
\label{section: Override keyword}
C++ Inheritance is one of the most significant mechanisms, which allows defining a class in terms of another class. Thus, it allows derived classes to reuse functions and data members that exist in base classes. The functions that will be used by derived classes must declare as virtual functions, to prevent a compiler from creating new versions of these functions. Then, specific implementation of functions can be added or replaced by derived class to become appropriate for doing particular purpose \cite{Stroustrup:2012:Cpp11}.


However, sometimes, when working with derived classes, it is possible to inadvertently create a new virtual function rather than overriding a function from the base class. This could occur when the function prototype is not properly matched with the one in base class or when adding a new parameters to a function in base class but forget to update the version in derived class \cite{Stroustrup:2012:Cpp11}.


This is very costly and not expresses programmer intent. In addition, these types of problems can be hard to find.


C++11 adds a new keyword called override that allows a programmer to explicitly mark virtual functions that will be overridden. Override keyword lets the programmer to be more explicit about overriding, and if function is not override or has wrong signature, the compiler will complain about that. Thus, this provides more control over functions and help to prevent inadvertent errors \ref{OverrideKeyword} \cite{Gregorie:professionalcpp}.

% Final keyword
\section{Final keyword}
\label{section: Final keyword}
There are occasionally times when a programmer may wants to prevent virtual function from being overridden. This feature is not supported by C++ because derived classes will inherit all functionality that is possible from base classes \cite{Stroustrup:2012:Cpp11}.


C++11 introduces the ability to prevent inheriting from classes and then functions cannot be overridden in derived classes. This can be achieved by marking a function with final keyword to make it non-override-able. This can also be applied to class to prevent it from being inherited \ref{FinalKeyword}.  Thus, any attempt to override final functions or class will result in a compiler error  \cite{Gregorie:professionalcpp}.

% Null pointer constatn
\section{Null pointer constant}
\label{section: Null pointer constant}
C++ language has the pre-processor macro called NULL, which was used with a pointer to refer that it is not pointing to anywhere. The problem with NULL is that, underneath it is just a plain 0. 


This raise some problems, for instance, consider a situation when a programmer defines two functions with the same name and one has int argument and other has a pointer argument. Then, calling the function with NULL parameter cause cease a program, because it cannot decide if NULL is actually a pointer (because it is a 0) or an integer (because NULL is a 0). Thus, this ambiguity causes a compiler error \cite{Cppreference:2012:Cpp11}.


C++11 solves this problem by introducing nullptr keyword, which is a null pointer constant that unambiguously represents a pointer pointing to nowhere; no zero at all. It considers a strongly typed null pointer and can be passed as a null pointer to a function without ambiguity \ref{NullPointer} \cite{Cppreference:2012:Cpp11}. 


% Enumerations
\section{Strongly typed enumerations}
\label{section: Strongly typed enumerations}
Enumerations of traditional C++ are not type-safe, and have some problems may cause catastrophic when used in life-critical software. One of these problems is implicit conversion between types. Although enumerations in C++ have some type safety features including preventing directly assign from one enumeration type to another and not implicit conversion from an integer to enumeration type, but the value or object of an enumerator is allowed to convert implicitly to integer.


Another problem is that, the underlying type of an enum cannot be specified explicitly by programmers. Therefore, it cannot be determined how much space will be used by the representation of an enumeration variable. Finally, enumerations in C++ are not strongly scoped and could raise some issues such as conflict can happen when two enumerations have enumerators with the same name in the same cope\cite{Stroustrup:2012:Cpp11}.


C++11 provides a new form of enumeration which combining enum with class and is declared by using keyword enum class and is used to handle the problems that existed in traditional C++.  Implicit conversions to or from an integer is not allowed in this type and any attempt doing that cause a compiler-error \ref{EnumerationClass_Implicit} \cite{Overland:2011:CWF}.


The underlying type of enum class is clearly specified, by default is integer.  A programmer can explicitly specify another type by writing type following the enumeration name \ref{EnumerationClass_Explicit}. C++11 Enumerations have class scope for their enumerators. This eliminates a possible source of name conflicts between enumerators from different enum definitions \ref{EnumerationClass_Conflict} \cite{Josuttis:2012:CppStandardLibrary}.


\section{Explicit Conversion Operators}
\label{section: Explicit Conversion Operators}

% Alias templates:
\section{Alias templates}
\label{section: Alias templates}
The type alias is mechanism that allows a programmer to create an alias, or synonym, for an existing data type, without creating new type.  This technique is useful to simplify declarations that could be widely used in a program and documenting it.


Traditional C++ supports this technique by using typedef keyword, which has syntax as follows:
\begin{center}
 typedef $<$the real data type$>$ $<$the alias identifier name$>$
\end{center}

The typedef keyword is pretty useful to provide suitable names when the real type declarations become complex to express. This could happen when dealing with Standard Library containers and templates. Thus, it reduces the amount of code necessary \cite{Gregorie:professionalcpp}.


However, using typedef keyword with template require specifying concrete types for each template type and this restricts a programmer to specify each parameter type explicitly in a program. Otherwise, it is not valid. In addition, using typedef keyword becomes complicated with function pointers and makes a code hard to read by ordinary programmer \ref{TypeAlias_FunctionPointer} \cite{Gregorie:professionalcpp}.


C++11 introduces a new mechanism for declaring type aliases called template aliases, that is applied by "using" keyword.  Template aliases make writing the code easier than the old typedef, and less error prone. They have straightforward syntax as follows that make a program easier to understand.

\begin{center}
using $<$the alias identifier name$>$ = $<$the real data type$>$
\end{center}

Template aliases can be used as the same as the typedef to create type aliases for variables \ref{TypeAlias_Varialbe}. They can also be declared as a pointer to function with a straightforward syntax, instead of declaring a pointer in the middle of syntax as exist in the old style \ref{TypeAlias_FunctionPointer} \cite{Gregorie:professionalcpp}.


Template aliases remove the limitations that exist with the old typedef in terms of dealing with templates. They allow a programmer to define type aliases for templates without concrete types, and give flexibility to the programmer to specify the type when an object is declared \ref{TypeAlias_Template} \cite{Gregorie:professionalcpp}.


Hence, type aliases are useful to make a code easier to read by having simple syntax and also provide flexibility to deal with a code.

\section{Summary}
\label{sect: Summary}


% Functionalit Improvements
\chapter{Core Language Functionality Improvements}
\label{chapter: Functionality Improvements}

XXX

\section{New character types : char16\_t and char32\_t}
\label{section: char16_t and char32_t}
The C++ language has extended a support character set over the last years. This included wide character (wchar\_t), which is a significant step forward because it has led to raise the amount of space usable to define a single character. In wide character sets, available space is used exactly as ASCII, each a number represents a special glyph, but the difference is that each number does not represent in 8 bits. The form of characters to numbers (now dubbed code points) is larger than it was, because it deals with lots of different sets in addition to the characters that are familiar by native English programmers \cite{Gregorie:professionalcpp}.


Both of Unicode Consortium and the Universal Character Set (UCS) that defined by the International Standard ISO10646, are standardized sets of characters. They include approximately 100000 abstract characters, and each defined by special name and an integer number named its code point. Both standards contain the same characters and their associated numbers and have particular encodings that could use by programmers. For instance, UTF-8 (which is stands for Unicode Transformation Format -8) is an example of a Unicode encoding, which use 8-bit blocks to encode a character. The number of blocks required to encode a character varies from one to four bits.  UTF-16 and UTF-32 encoded Unicode characters as one or two 16-bit values, and as exactly 32 bits, respectively \cite{Gregorie:professionalcpp}.


Different encodings could be used by different applications. Unfortunately, wide character (wchar\_t) that introduced by C++, was not enough, because the size of wchar\_t can change from one implementation to another. For example, on Windows it is 16 bits, whereas on other operating system could be 32 bits \cite{Gregorie:professionalcpp}. 


To address this issue, C++11 comes with two new types char16\_t and char32\_t, which use to store 16 and 32 bits respectively. They can be used as the basic building block for UTF-16 and UTF-32 encoded Unicode characters \cite{Josuttis:2012:CppStandardLibrary}.


C++11 use the “u” prefix to represent a character literal of type char16\_t and ensuring its value equal to its ISO 10646 (and Universal Character Set) code point value, that is represented in a single 16-bits \ref{NewCharacterType_char16}. It also uses the same prefix to represent string constants in 16-bits form \ref{NewCharacterType_String16} \cite{Josuttis2012:CppStandardLibrary}.


Similarly, the "U" prefix is used to represent a character literal \ref{NewCharacterType_char32} and string constants in 32-bits form \ref{NewCharacterType_String32}.  Supporting for Unicode by C++11 is not only limited over these two types. The UTF-8 is also supported and can be represented by using the “u8” prefix in front of string, indicating that the contents of string are stored in UTF-8 \ref{NewCharacterType_UTF-8} \cite{Josuttis:2012:CppStandardLibrary}.


Unicode Characters for universal languages are also supported in these new characters types. Thus, it is possible to writing a string, for example, in Arabic language because each character has unique name and number \ref{NewCharacterType_Languages} \cite{Josuttis:2012:CppStandardLibrary}.


In these types of strings, adjacent string literals concatenate if they have the same encoding-prefix and thus, leading to a single concatenated string literal with that encoding-prefix. This can be also applied when on string literal has not encoding-prefix, it handle as a string literal of the same encoding-prefix as the other operand \ref{NewCharacterType_String16}, \ref{NewCharacterType_String32}, \ref{NewCharacterType_UTF-8} \cite{ ISO:2011:Cpplanguage}.


% Raw string literals
\section{Raw string literals}
\label{section: Raw string literals}
Recently, C++ gained popularity by dealing with markup languages including XML and HTML as well as regular expressions that added by C++11 to the Standard Library to express patterns to be matched against strings. However, this has raised several problems for programmers including a difficulty to writing plethora of backslashes correctly and impenetrable to read, because the same backslash escape sequence is used by regular expressions and C++ in string literals. Additionally, quotation marks and newlines are widely used by mark-up languages, leading escape sequences in string literals are difficult to process, error-prone and cumbersome as well as breaking a string into multiple lines of code is not allowed in C++ \cite{ISO:2011:Cpplanguage}.


C++11 comes with new concept called raw string literals that does not process escape sequences like $\backslash$t and $\backslash$n as C++ does, instead, as normal text. Raw literal is a string literal with R prefix and has format R "d-char-sequence(r-char-sequence) d-char-sequence". Meaning that, d-char-sequence (delimiter sequence) could be any symbol such as (-, "(), \~) or text (delimiter) and it is considered optionally. Delimiter sequence must be the same at the starting and at the end of the raw string and can be up to 16 characters. The r-char-sequence is the actual raw string, which can represent text, symbols, escape sequences and quotation marks easily \cite{Gregorie:professionalcpp}.


Raw string is significantly useful in terms of regular expressions. It offers sophisticated and easy way to represent backslashes and other symbols that could use to express specific patterns against sequences of characters \ref{RawString_Backslash}.


Raw string is also used to represent easily quotation marks and escape sequence, which are massively used by XML and HTML languages \ref{RawString_EscapeSequence}. Thus, it allows for much more sophisticated string handling with less error-prone such as representing whole code of HTML, without any restriction \ref{RawString_HTML}.


Raw string literals can be combined with Unicode literal prefixes  (“u8”,"u" and "U") to represent the content of raw string in 16 and 32-bits \ref{RawString_UnicodeliteralPrefix} \cite{Gregorie:professionalcpp}.

% user-defined literals
\section{User-defined literals}
\label{section: User-defined literals}
C++ has a number of standard literals such as hexadecimal (0xabc), floating point value (3.14f) and string literals (zero-terminated array of character in C-style string), which can be used to achieve specific purpose by a user. For example, literal "f" in "12.2f" is used to converts the double value to float. 


The problem is that, these literals are not very flexible to manipulate, on the contrary, they fairly fixed because they are built-in types in C++. Therefore, the user cannot change them to other ones or create new ones to achieve everything that he wants \cite{Overland:2011:CWF}.


C++11 overcomes this situation by introducing new concept called "user-defined literals", which gives the user the ability to create new custom literal modifiers. User defined literals should start with an underscore to specify a fixed value and are implemented by the compiler according to literal operators.


Literals operators are restricted with these types namely, char const*, unsigned long long, long double, (char const*, std::size\_t), (wchar\_t const*, std::size\_t), ( char16\_t const*, std::size\_t), and (char32\_t const*, std::size\_t). Literals operators can be used to invoke functions when a program contains more than one user-defined literal with same fixed value \ref{UserLiterals_LiteralOperators} \cite{Gregorie:professionalcpp}.


Literal operators can be classified to raw or cooked style. In raw style, literal operator receives data as a sequence of characters for processing, for instance , C++ literal 345 will receive as a sequence of characters '3', '4', '5', which can be only represented by type of  const char*. Raw style has the syntax:
\begin{center}
Return\_type  operator " " \_ suffix (const char *)
\end{center}

Return\_type is used to determine the return type of user-defined literal and suffix is used to specify the fixed value that defines by user. Raw style uses this syntax to deal with data and producing new types that correspond to user purpose.  Thus, it offers flexibility to the user to create, for example, literals that convert from binary to decimal and vice versa \ref{UserLiterals_RawStyle} \cite{Gregorie:professionalcpp}.


Cooked style, on the other hand, literal operator receives a specific interpreted type such as 345 as representing to C++ literal above. Cooked style has the same syntax as raw style except a literal operator can be either one parameter or two parameters. One parameter can be represented by either unsigned long long or long double. This type could be used to receive one of these types and return other types depending on user purpose, for example, the user can write literals that receive kilometre and mile as long long type and return the equivalent as int \ref{UserLiterals_CookedStyle1} \cite{Gregorie:professionalcpp}.


On the other hand, literal operator could be two parameters, where the first is a character array and the second is the length of the character array and the second representing the length of that array. This type is usually used to deal with strings. For example, the user can gain benefit of these type by representing a literal operator as const char* (C-style string), and then convert it to std::string (C++ string) as a return type \ref{UserLiterals_CookedStyle2} \cite{Gregorie:professionalcpp}.


The user-defined literals can create either built-in type (e.g.  Float and int) or user-define types (e.g. classes), and the reality that they could be pretty useful is an effect that they can return objects instead of only primitives \ref{UserLiterals_CookedObject} \cite{Gregorie:professionalcpp}.


% default keyword
\section{Explicitly Defaulted special member functions}
\label{section: Defaulted special member functions}
By default, C++ provides special member functions if they are not declared explicitly namely, default constructor, copy constructor, copy assignment operator, move constructor, move assignment operator, and destructor.


The management of special member functions that provided by C++ raise some problems and difficulty, including the default version of these functions are suppressed, when declaring any of which by a programmer, and the default destructor is not suitable to polymorphic classes, which used as abstract classes for many derived classes. Thus, they require explicit definition and appropriate control to achieve their purposes \cite{ISO:2011:Cpplanguage}.


On the other hand, in some cases, a programmer may want to disable default copies of special member functions and prevent C++ compiler to generate them. With traditional C++ such troubles could face the programmer and there is no appropriate way to control default implementations and manage them efficiently \cite{ISO:2011:Cpplanguage}.


C++11 supports the concepts of explicitly defaulted, which provide full control over special member functions as well as allowing a programmer to deal with a program in efficient way. This concept is applied by using default keyword, which must follows the declaration of special member functions, indicating that they defined as default explicitly \cite{Prata:2012:Cpp}.


A function that can be explicitly defaulted should be a special member, and declared function type should be the same as if it had been implicitly declared, and not have default arguments \cite{ISO:2011:Cpplanguage}.


Using the concept of explicitly defaulted handles some issue that could face a programmer when dealing with class for instance, when the programmer does not specify any constructor and he creates object without arguments. A program still works because compiler will write one that does not take any arguments, but defining constructor that takes arguments leads to compiler-error, because the default constructor is suppressed when constructor with arguments was defined. This issue can be handled by using default keyword to define explicitly defaulted constructor and without writing the rest of code \ref{DefaultKeyword_Constructor}. Thus, default keyword forces a compiler to provide default version of special member functions under any circumstance \cite{Gregorie:professionalcpp}.


The default keyword offers more facilities to control functions that should be used in a program and saves programmer efforts to write entire code of function if it is not required in the program.  Declaring functions  explicitly by using default keyword, indicate  that  a programmer is  aware about  default functions that could generated by compiler , and also appear as documentation for the program to express clearly  the intent of a programmer \cite{Horstmann:2008:BC}.


The default keyword can also be used to change the accessibility of special member functions because a compiler defines them by default as public. Hence, a programmer may want to change them to protected or even private in sometimes depending on purpose of program \ref{DefaultKeyword_ClassAccessibility} \cite{Williams:2012:CCA}.


As a result, the default keyword is used to force a compiler to provide default implementation for special member functions anyway and declare them clearly. Disabled these copies is also possible by C++11, which will explain in following topic.


% delete keyword
\section{Explicitly Deleted special member functions}
\label{section: Deleted special member functions}
The explicitly deleted functions is also supported by C++11. This can be done by prototyping the function and using the delete keyword. The delete keyword has significant role to control of implementation without causing compile error. In C++, standard way for preventing copies of constructor and assignment operator is placing them in the private section of a class without providing an implementation. This could leads to compiler error or link time-error by trying to copy an instance from outside the class or even using the class's member functions. Moreover, it could be not obvious the purpose of doing that \cite{Horstmann:2008:BC}.


An alternative way to accomplish that is to use the delete keyword to explicitly disable functions of a class and even the associated function cannot be invoked, nor using a default implementation. The benefit of that can be gained by defining explicitly class that has move concept only. This can be done by defining explicitly move constructor and move assignment operator, without copy constructor and copy-assignment operator. Thus, the class becomes move-only \ref{DeleteKeyword_ClassMove} \cite{Horstmann:2008:BC}.


The delete keyword is also used to prevent the compiler from using particular methods, for instance, a programmer can use delete keyword to prevent use of a class in certain new expressions, and attempting to create object using new expressions, will lead to compiler error \ref{DeleteKeyword_NewExpression} \cite{ISO:2011:Cpplanguage}.


The usage of delete keyword has useful role to address overloading issues including calling a member function with certain parameters.  For instance, suppose that programmer define function called f () that takes integer value. When calling this function with double value, a compiler will convert the double value to an integer value and then call function f (int i). As a result, implicit conversion is executed by the compiler. To avoid this issue, the keyword delete can be followed a double instance of function f () to explicitly deleted overloaded functions, and then a compiler will be flagged as an error by calling f () with double value \ref{DeleteKeyword_Overload} \cite{Gregorie:professionalcpp}.

% long long int 
\section{Unsigned long long (int) and long long (int)}
\label{section: Unsigned and long long (int)}
In traditional C++, the largest integral type is long int type which guarantees to have at least as many usable bits as int.  This type was necessary exist to address the limitation of short type, which ensures 16-bit integers. However, long type cannot always guarantees 64 bits in each implementation such as 32-bit systems, and also cannot store big numbers with absolute precision.


 Due to these limitations, C++11 introduces the types long long and unsigned long long to overcome these issues. These new data types are guaranteed to be at least 64-bits, regardless of the platform. Hence, they able to store astronomical values far beyond of long int type. The declaration of unsigned and long long integers is similar to long int type, except using new "LL" and "ULL" suffixes with long long and unsigned long long respectively, to ensure that big numbers can be stored effectively \ref{Long}, \ref{UnsignedLong} \cite{Overland:2011:CWF}.

% static assertion
\section{Static assertion}
\label{section: Static assertion}
The traditional C++ provides two facilities for testing software assertions namely, the \#error preprocessor directive and the assert macro. Both of which are inappropriate for use in template libraries.  To impose a template parameter constraint, for instance, writing assertion must be possible for testing when the associated template is instantiated.


The processing of the \#error preprocessor directive comes ahead of time to be of a good use in this regard. In particular, the \#error directive is processed before templates are instantiated, and thus cannot be used to test assertions involving template arguments. In addition to that, preprocessor is unable to recognize the sizeof operator during the processing until after preprocessor directives have executed.


The assert macro, on the other hand, tests assertions at runtime, which considers far later than would be required by the user of a template library, and which involves a runtime performance cost \cite{Stroustrup:2012:Cpp11}.


C++11 adds new concept dubbed static\_assert, which tests a software assertion at compile time, instead of run time. The declaration of static\_assert requires two parameters; constant-expression and string-literal as following syntax:
\begin{center}
static\_assert (constant-expression, string-literal).
\end{center}

If the expression evaluates to false (0), the compiler will issue an error that contains the string literals which is provided in the declaration. Otherwise, static\_assert declaration has no effect.


The static\_assert has significant support for library development by letting libraries to detect incorrect usage at compile time and report them much more effectively. It also makes learning and teaching C++ easier by allowing C++ Standard Library implementations to provide more informative error messages when common usage mistakes are detected \cite{MSDN:2012:CppModern}.


Static\_assert could be used at namespace scope as alternative to the \#error preprocessor directive if there is demand should always be true \ref{StaticAssert_Namespace}.


The static\_assert is primarily useful inside classes that are templates, to check validation of template parameters at compile time for instance, it ensure that template parameters must be unsigned int before they use inside the class  to achieve specific purpose \ref{StaticAssert_ClassTemplate} \cite{Deitel:2012:CPP}.


Using static\_assert has benefit over type traits, which has added to the library of C++11. Type traits also allow making decisions based on relations and types at compile time, and the combination of both are pretty powerful. For instance, static\_assert is used with type traits to ensure type of the relation between two classes, whether is based on relation or is same relation \ref{StaticAssert_TypeTraitSame}. It also used to assert whether a variable is float point or not \ref{StaticAssert_TypeTraitFloat} \cite{Gregorie:professionalcpp}.

% variadic template
\section{Variadic template}
\label{section: Variadic template}
Templates are one of the most powerful features that use as essential tools for generic programming in C++ language. Templates are widely used with functions and classes to avoid duplicated code that could be rewritten for each specific purpose.


In traditional C++, using templates to implement generic functions and classes are quite restricted, because they require specifying a fixed number of type parameters in the declaration. Implementing these with extra parameters, require corresponding cod to be repeated several times as well as overloaded functions \cite{Stroustrup:2012:Cpp11}.


However, generic functions and classes that take a variable number of template parameters are very useful, for example, to construct classes and functions with indefinite number of parameters, and without duplicate code. Additionally, constructing std::tuple (which added to C++11 for storing any number of values with their types), require providing different numbers and types of values in each implementation, and then resulting a code must be rewritten according to numbers and type of values that provided \cite{Stroustrup:2012:Cpp11}.


C++11 bring in the notion of variadic templates, which has the ability to create template classes and functions that take a variable number of template parameters. This can be achieved by using a parameter called parameter pack which also introduced by C++11.


\subsection{Parameter pack}
\label{subsection: Parameter pack}
parameter pack is not the same as previous parameters for C++ templates, which has the ability to only bind to a single argument. On the contrary, it can pack multiple parameters into a single parameter by placing ellipsis meta-operator after the keyword typename, indicating to a parameter can represent a list of types as follows syntax:
\begin{center}
template $<$typename... Args$>$
\end{center}

As it is shown, Args is a parameter pack. The variadic template also brings pack expansion, which showing that a parameter pack can be expanded. Thus, in the template definition, a parameter pack is handled as a single parameter, whereas in the template instantiation, it expands to match the exact number of the parameters that are created \cite{Gregorie:professionalcpp}.


In general, a parameter pack can be represented by either a function parameter pack or template parameter pack.

\begin{enumerate}
\item \textbf{Template parameter packs} is a template parameter that represent a variable number of template parameters, including zero template parameter.  As mentioned above, this can be achieved by using an ellipsis with template parameter \cite{Gregorie:professionalcpp}.
\begin{center}
template$<$typename B, typename... A$>$ class C\{\}; 
\end{center}


\item \textbf{Function parameter packs} A function parameter pack is a function parameter that can be represented by zero or many function parameters. This can be achieved by using ellipsis with function parameter. In the context of defining a function template, template parameter pack is used to declare a function parameter pack, and then it is expanded by the function parameter pack as the follows \cite{Gregorie:professionalcpp}.
\begin{center}
template$<$typename...C$>$ void f(C...args)
\end{center}

Variadic template allows you to define function parameter pack and template parameter pack which will be used as follows.

\end{enumerate}

\subsection{Type-safe Variadic Functions}
Variadic templates are used with functions templates to provide type-safe variadic functions, which are one of the most significant uses of variadic template parameters. This can be achieved through combining variadic templates with template parameter to achieve such safe type \cite{Gregor:2007:VTC}.


For instance, a variadic template can be used with function template to define a function called f () that takes multiple arguments with different types in a type-safe way. The function f () will process each value that provide as arguments and will invoke a function called specify\_type () to handle each individual argument. This requires to provide the function specify\_type () for each type that exist in a program such as int, char and double \ref{VariadicTemplate_Function} \cite{Gregorie:professionalcpp}.


The function f () is overload twice, the first time, is considered as a partial specialization of a second function f (), which accept argument each time and will execute the function specify\_type () according to type that is provided.  The fact of declaring this function is to stop recursive manner that is happen in the second function.


The second time, it is a recursive function, it takes two arguments, one is a template parameter (T) that invoke first function f () for each argument, and second is function parameter pack, which expand to represent a correct number of arguments and then call f () function with those expanded arguments.


The implementation of second function f () is recursive, and will lead the parameters to be copied for each invoke. Thus, it becomes pretty costly for some types of arguments. This can be avoided by using rvalue references which provided by C++11 to pass arguments to the function f (), without duplicate copies \ref{VariadicTemplate_Function} \cite{Gregorie:professionalcpp}.


The facilities that provided by variadic template to function template, allow to apply something extraordinary such as function that takes arguments int, char and double and store them in arrays according to type that belong to \ref{VariadicTemplate_Function1}.


The facilities that provided by variadic template over function template is not restricted here, it allows a user to write a tuple function that behave as the same as std::make\_tuple, which is provided by std::tuple. This offers easier way to make tuple with arbitrary values \ref{VariadicTemplate_Tuple} \cite{Gregorie:professionalcpp}.


% Variadic Mix-In Classes 
\subsection{Variadic Templates and Mix-In Classes}
\label{subsection: Variadic Templates and Mix-In Classes}
A Mix-in is class that refers to as template class, which provides a certain functionality to be inherited or just reused by derived classes. It allows implementing different implementation concerns in different classes and then composing a final class which has the whole, composed interface.


Mix-in class is implemented by having an inherited template parameter, which specifies a base class that will be used as well as arguments numbers of constructors that are not known.\\

Using variadic template is significantly useful with mix-in class because its parameter pack can be used as inheriting template parameter for mix-in class. Thus, it possible to provide variable number of base classes that is going to be inherited by mix-in class \cite{Gregor:2007:VTC}.


As a result, variadic template offers new facilities that have significant impact to address some limitations in the current implementations of C++ \ref{VariadicTemplate_Class} \cite{Gregor:2007:VTC}.

\section{Summary}
\label{section1: Summary}

% conclsion
\chapter{Conclusion}
\label{sec: conclusion}

% References
\addcontentsline{toc}{section}{Bibliography}
\bibliographystyle{alpha}
\bibliography{Bibliography}	


\begin{appendix}

\chapter{Program Code}
\label{chapter:Programcode}


\section{MakeFile}
\label{Makefile}

\Make

%\lstinputlisting{../Makefile}
\newpage


% Core language Runtime Performance Enhancements
\section{Core Language Runtime Performance Enhancements}
\label{Appendix: corelanguage runtime performance}

\Cpp

% Rvalue reference
\subsection{RvalueReference\_Basic.cpp}
\label{RvalueReference_Basic}
\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Basic.cpp}

\subsection{RvalueReference\_Parameter.cpp}
\label{RvalueReference_Parameter}
\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Parameter.cpp}

\subsection{RvalueReference\_Move.cpp}
\label{RvalueReference_Move}
\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Move.cpp}

\subsection{RvalueReference\_Template.cpp}
\label{RvalueReference_Template}
\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Template.cpp}

\subsection{RvalueReference\_Forwarding.cpp}
\label{RvalueReference_Forwarding}
\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Forwarding.cpp}

% Move semantic
\subsection{MoveSemantic\_Constructor.cpp}
\label{MoveSemantic_Constructor}
\lstinputlisting{../CoreLanguage/RunTime/MoveSemantic_Constructor.cpp}

\subsection{MoveSemantic\_AssignmentOperator.cpp}
\label{MoveSemantic_AssignmentOperator}
\lstinputlisting{../CoreLanguage/RunTime/MoveSemantic_AssignmentOperator.cpp}

\subsection{MoveSemantic\_Swap.cpp}
\label{MoveSemantic_Swap}
\lstinputlisting{../CoreLanguage/RunTime/MoveSemantic_Swap.cpp}

% Generliazed constant expression
\subsection{Constexpr\_Data.cpp}
\label{Constexpr_Data}
\lstinputlisting{../CoreLanguage/RunTime/Constexpr_Data.cpp}

\subsection{Constexpr\_Recursion.cpp}
\label{Constexpr_Recursion}
\lstinputlisting{../CoreLanguage/RunTime/Constexpr_Recursion.cpp}

\subsection{Constexpr\_ArraySize.cpp}
\label{Constexpr_ArraySize}
\lstinputlisting{../CoreLanguage/RunTime/Constexpr_ArraySize.cpp}

\subsection{Constexpr\_FunctionRuntime.cpp}
\label{Constexpr_FunctionRuntime}
\lstinputlisting{../CoreLanguage/RunTime/Constexpr_FunctionRuntime.cpp}

\subsection{Constexpr\_ConstantConstructor.cpp}
\label{Constexpr_ConstantConstructor}
\lstinputlisting{../CoreLanguage/RunTime/Constexpr_ConstantConstructor.cpp}

% POD
\subsection{POD\_TrivialClass.cpp}
\label{POD_TrivialClass}
\lstinputlisting{../CoreLanguage/RunTime/POD_TrivialClass.cpp}

\subsection{POD\_StandardLayoutClass.cpp}
\label{POD_StandardLayoutClass}
\lstinputlisting{../CoreLanguage/RunTime/POD_StandardLayoutClass.cpp}

\subsection{POD\_StandardLayoutandTrivialClass.cpp}
\label{POD_StandardLayoutandTrivialClass}
\lstinputlisting{../CoreLanguage/RunTime/POD_StandardLayoutandTrivialClass.cpp}

% Core Language Usability Enhancements
\section{Core Language Usability Enhancements}
\label{Appendix: corelanguage usabiliy enhancements}

\Cpp

% Uniform initialization
\subsection{UniformInitialization\_ClassMembers.cpp}
\label{UniformInitialization_ClassMembers}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/UniformInitialization_ClassMembers.cpp}

\subsection{UniformInitialization\_Array.cpp}
\label{UniformInitialization_Array}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/UniformInitialization_Array.cpp}

\subsection{UniformInitialization\_DynamicArray.cpp}
\label{UniformInitialization_DynamicArray}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/UniformInitialization_DynamicArray.cpp}

\subsection{UniformInitialization\_ObjectReturn.cpp}
\label{UniformInitialization_ObjectReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/UniformInitialization_ObjectReturn.cpp}

\subsection{UniformInitialization\_Narrowing.cpp}
\label{UniformInitialization_Narrowing}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/UniformInitialization_Narrowing.cpp}

% Initializer list
\subsection{InitializerList\_Constructor.cpp}
\label{InitializerList_Constructor}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/InitializerList_Constructor.cpp}

\subsection{InitializerList\_Vector.cpp}
\label{InitializerList_Vector}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/InitializerList_Vector.cpp}

\subsection{InitializerList\_Function.cpp}
\label{InitializerList_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/InitializerList_Function.cpp}

% Auto keyword
\subsection{AutoKeyword\_Variable.cpp}
\label{AutoKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Variable.cpp}

\subsection{AutoKeyword\_ConstVolatile.cpp}
\label{AutoKeyword_ConstVolatile}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_ConstVolatile.cpp}

\subsection{AutoKeyword\_NewExpression.cpp}
\label{AutoKeyword_NewExpression}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_NewExpression.cpp}

\subsection{AutoKeyword\_Function.cpp}
\label{AutoKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Function.cpp}

\subsection{AutoKeyword\_MapContainer.cpp}
\label{AutoKeyword_MapContainer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_MapContainer.cpp}

\subsection{AutoKeyword\_InitializerList.cpp}
\label{AutoKeyword_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_InitializerList.cpp}

\subsection{AutoKeyword\_Template.cpp}
\label{AutoKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Template.cpp}

% Decltype keyword
\subsection{DecltypeKeyword\_Variable.cpp}
\label{DecltypeKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Variable.cpp}

\subsection{DecltypeKeyword\_lvalue.cpp}
\label{DecltypeKeyword_lvalue}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_lvalue.cpp}

\subsection{DecltypeKeyword\_Function.cpp}
\label{DecltypeKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Function.cpp}

\subsection{DecltypeKeyword\_Template.cpp}
\label{DecltypeKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Template.cpp}

% alternative function syntax
\subsection{AlternativeFunction\_Syntax.cpp}
\label{AlternativeFunction_Syntax}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Syntax.cpp}

\subsection{AlternativeFunction\_This.cpp}
\label{AlternativeFunction_This}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_This.cpp}

\subsection{AlternativeFunction\_Template.cpp}
\label{AlternativeFunction_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Template.cpp}

\subsection{AlternativeFunction\_Scope.cpp}
\label{AlternativeFunction_Scope}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Scope.cpp}

% Ragne-based for statement
\subsection{RangeFor\_Array.cpp}
\label{RangeFor_Array}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Array.cpp}

\subsection{RangeFor\_InitializerList.cpp}
\label{RangeFor_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_InitializerList.cpp}

\subsection{RangeFor\_Vector.cpp}
\label{RangeFor_Vector}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Vector.cpp}

\subsection{RangeFor\_UniformInitialization.cpp}
\label{RangeFor_UniformInitialization}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_UniformInitialization.cpp}

% Lambda Expression
\subsection{Lambda\_Mutable.cpp}
\label{Lambda_Mutable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Mutable.cpp}

\subsection{Lambda\_FunctionParameter.cpp}
\label{Lambda_FunctionParameter}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionParameter.cpp}

\subsection{Lambda\_Invocation.cpp}
\label{Lambda_Invocation}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Invocation.cpp}

\subsection{Lambda\_Foreach.cpp}
\label{Lambda_Foreach}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Foreach.cpp}

\subsection{Lambda\_ExplicitReturn.cpp}
\label{Lambda_ExplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ExplicitReturn.cpp}

\subsection{Lambda\_ImplicitReturn.cpp}
\label{Lambda_ImplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ImplicitReturn.cpp}

\subsection{Lambda\_PointerFunction.cpp}
\label{Lambda_PointerFunction}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_PointerFunction.cpp}

\subsection{Lambda\_FunctionReturnType.cpp}
\label{Lambda_FunctionReturnType}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionReturnType.cpp}

\subsection{Lambda\_Sort.cpp}
\label{Lambda_Sort}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Sort.cpp}

% Delegating Constructors
\subsection{DelegatingConstructor.cpp}
\label{DelegatingConstructor}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DelegatingConstructor.cpp}

% Override keyword
\subsection{OverrideKeyword.cpp}
\label{OverrideKeyword}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/OverrideKeyword.cpp}

% Final keyword
\subsection{FinalKeyword.cpp}
\label{FinalKeyword}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/FinalKeyword.cpp}

% Null pointer constant
\subsection{NullPointer.cpp}
\label{NullPointer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/NullPointer.cpp}

% Strongly Typed Enumerations
\subsection{EnumerationClass\_Implicit.cpp}
\label{EnumerationClass_Implicit}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Implicit.cpp}

\subsection{EnumerationClass\_Explicit.cpp}
\label{EnumerationClass_Explicit}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Explicit.cpp}

\subsection{EnumerationClass\_Conflict.cpp}
\label{EnumerationClass_Conflict}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Conflict.cpp}

% Alias Template
\subsection{TypeAlias\_FunctionPointer.cpp}
\label{TypeAlias_FunctionPointer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_FunctionPointer.cpp}

\subsection{TypeAlias\_Varialbe.cpp}
\label{TypeAlias_Varialbe}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_Variable.cpp}

\subsection{TypeAlias\_Template.cpp}
\label{TypeAlias_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_Template.cpp}



% Core Language Functionality Improvements
\section{Core Language Functionality Improvements}
\label{Appendix: corelanguage functionality improvements}

\Cpp

% NewCharacterType - char16 and char32
\subsection{NewCharacterType\_char16.cpp}
\label{NewCharacterType_char16}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_char16.cpp}

\subsection{NewCharacterType\_String16.cpp}
\label{NewCharacterType_String16}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_String16.cpp}

\subsection{NewCharacterType\_char32.cpp}
\label{NewCharacterType_char32}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_char32.cpp}

\subsection{NewCharacterType\_String32.cpp}
\label{NewCharacterType_String32}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_String32.cpp}

\subsection{NewCharacterType\_UTF-8.cpp}
\label{NewCharacterType_UTF-8}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_UTF-8.cpp}

\subsection{NewCharacterType\_Languages.cpp}
\label{NewCharacterType_Languages}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_Languages.cpp}

% Raw string literals
\subsection{RawString\_Backslash.cpp}
\label{RawString_Backslash}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_Backslash.cpp}

\subsection{RawString\_EscapeSequence.cpp}
\label{RawString_EscapeSequence}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_EscapeSequence.cpp}

\subsection{RawString\_HTML.cpp}
\label{RawString_HTML}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_HTML.cpp}

\subsection{RawString\_UnicodeliteralPrefix.cpp}
\label{RawString_UnicodeliteralPrefix}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_UnicodeliteralPrefix.cpp}

% User-defined literals
\subsection{UserLiterals\_LiteralOperators.cpp}
\label{UserLiterals_LiteralOperators}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UserLiterals_LiteralOperators.cpp}

\subsection{UserLiterals\_RawStyle.cpp}
\label{UserLiterals_RawStyle}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UserLiterals_RawStyle.cpp}

\subsection{UserLiterals\_CookedStyle1.cpp}
\label{UserLiterals_CookedStyle1}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UserLiterals_CookedStyle1.cpp}

\subsection{UserLiterals\_CookedStyle2.cpp}
\label{UserLiterals_CookedStyle2}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UserLiterals_CookedStyle2.cpp}

\subsection{UserLiterals\_CookedObject.cpp}
\label{UserLiterals_CookedObject}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UserLiterals_CookedObject.cpp}

% default keyword
\subsection{DefaultKeyword\_Constructor.cpp}
\label{DefaultKeyword_Constructor}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/DefaultKeyword_Constructor.cpp}

\subsection{DefaultKeyword\_ClassAccessibility.cpp}
\label{DefaultKeyword_ClassAccessibility}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/DefaultKeyword_ClassAccessibility.cpp}

% delete keyword
\subsection{DeleteKeyword\_ClassMove.cpp}
\label{DeleteKeyword_ClassMove}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/DeleteKeyword_ClassMove.cpp}

\subsection{DeleteKeyword\_NewExpression.cpp}
\label{DeleteKeyword_NewExpression}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/DeleteKeyword_NewExpression.cpp}

\subsection{DeleteKeyword\_Overload.cpp}
\label{DeleteKeyword_Overload}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/DeleteKeyword_Overload.cpp}

% long long 
\subsection{Long.cpp}
\label{Long}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/Long.cpp}

% unsinged long long
\subsection{UnsignedLong.cpp}
\label{UnsignedLong}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/UnsignedLong.cpp}

% static assert
\subsection{StaticAssert\_Namespace.cpp}
\label{StaticAssert_Namespace}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/StaticAssert_Namespace.cpp}

\subsection{StaticAssert\_ClassTemplate.cpp}
\label{StaticAssert_ClassTemplate}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/StaticAssert_ClassTemplate.cpp}

\subsection{StaticAssert\_TypeTraitSame.cpp}
\label{StaticAssert_TypeTraitSame}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/StaticAssert_TypeTraitSame.cpp}

\subsection{StaticAssert\_TypeTraitFloat.cpp}
\label{StaticAssert_TypeTraitFloat}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/StaticAssert_TypeTraitFloat.cpp}

% varidaci template
\subsection{VariadicTemplate\_Function.cpp}
\label{VariadicTemplate_Function}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/VariadicTemplate_Function.cpp}

\subsection{VariadicTemplate\_Function1.cpp}
\label{VariadicTemplate_Function1}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/VariadicTemplate_Function1.cpp}

\subsection{VariadicTemplate\_Tuple.cpp}
\label{VariadicTemplate_Tuple}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/VariadicTemplate_Tuple.cpp}

\subsection{VariadicTemplate\_Class.cpp}
\label{VariadicTemplate_Class}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/VariadicTemplate_Class.cpp}


\end{appendix}

\end{document}
