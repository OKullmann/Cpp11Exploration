\documentclass[11pt]{report}

\usepackage{a4}
\usepackage{graphicx}
\usepackage{hyperref}

% For program-code:
\usepackage{listings}
\lstloadlanguages{C++,make}
\newcommand{\Cpp}{\lstset{language=C++,keywordstyle=\bfseries,breaklines,breakindent=30pt}}
\newcommand{\Make}{\lstset{language=make}}
\newcommand{\inl}[1]{\lstinline$#1$}

\Cpp


\begin{document}

\author{Dilshad Sallo\\[1ex]
  Computer Science Department\\
  College of Science, Swansea University\\
  Swansea, SA2 8PP, UK\\[1ex]
  Student Number: 59950\\
  Under Supervision of Dr. Oliver Kullmann
}

\title{C++11 by Examples}

\maketitle



\begin{abstract}

C++11 is new standard that released by C++ committee standard representing the effort of most expert in the world. This version includes new features that addresses some limitations exist in traditional C++ as well as providing new features that never existed in any previous versions. These features support a core language and some libraries and  provide new facilities  to make programming easier than before.

The aim of this project is to investigate some of these features (core \linebreak language features) and providing examples to get most out of them and show them as scientific catalogue to support  ordinary programmers.

This paper focuses on investigating core language features which classify to categories depending in which they belong to. Then, it clearly explains the structure  and  approach of achievement the project which should be mentioned in order to explain how the project will be implemented in the  summer. Finally, it should not be forgotten the important part of this report is the time management which  I use it to arrange the time in the summer to reach the purpose of project.
\end{abstract}

\tableofcontents

% chapter Core Language Runtime Performance Enhancements
\chapter{Core Language Runtime Performance Enhancements}
\label{chapter: Runtime Performance Enhancements}

\section{Introduction}
\label{section: Introduction}

\section{Rvalue references}
\label{section: Rvalue references}

\section{Move semantic}
\label{section: Move semantic}

\section{Generalized constant expressions}
\label{section: Generalized constant expressions}

\section{Modification of the definition of plain old data}
\label{section: Modification of the definition of plain old data}

\section{Conclusion}
\label{section: conclusion}


% chapter Core Language Usability Enhancements
\chapter{Core Language Usability Enhancements}
\label{chapter: Usability Enhancements}

\section{Introduction}
\label{section: Introduction}

\section{Uniform initialization}
\label{section:Uniform initialization}

\section{Initializer lists}
\label{section: Initializer lists}


% Auto keyword
\section{Type inference - Auto keyword}
\label{section: Auto keyword}
Many programming languages such Java, C and traditional C++ obligate a programmer to specify data type of variables before initializing and using them in a program. However, with the advent of template types and meta-programming techniques, type names become extremely long and complicated, especially, determining return value of function that used with template classes or using specified names for iterators combined with template classes \cite{Horstmann:2008:BC}.
\newline

In these cases, the data types required for these declarations become complex, ambiguous, and cannot be easily determined by an ordinary programmer.
\newline

C++11 adds significant feature to type inferences called auto keyword, which deduce variable types automatically based on the initializer expression at compile-time.  The auto keyword considers one of the most important features that added to C++11 due to its role to make programming easier to write and understand as well as improving generic programming \cite{Gregorie:professionalcpp}.
\newline

The keyword auto can be used in place of a data type to define build-in types such as int, long and etc, depending on initialization expressions \ref{AutoKeyword_Variable}. It can also be used with const and volatile qualifiers to define const and volatile pointer \ref{AutoKeyword_ConstVolatile}. Additionally, direct initialization syntax with new expressions is permitted by using auto keyword, for instance, the expression auto(1.2) has type double, and thus, new auto(1.2) has type double*. Combination of both will give, auto* d = new auto (1.2). And here, new auto (1.2) has type double*, which will be type of d as well \ref{AutoKeyword_NewExpression} \cite{Stroustrup:2012:Cpp11}.

In many cases, C++ programmers could use some exotic types such as function that return pointer to pointer, and could be hard to determine the return type properly, particularly, when it used with template classes. The auto keyword can be placed in such situation, to let compiler to deduce the data type that is returned from function and making a code easier to write and understand \ref{AutoKeyword_Function} \cite{Overland:2011:CWF}.
\newline

Using auto keyword to infer the type of a variable from initialization is most useful when that type is either difficult to know exactly or difficult to write by a programmer. Suppose a programmer has a map container that maps string to a vector of unsigned an integer as follows: 

\begin{center}
std::map$<$std::string,std::vector$<$unsigned int$>>$ mv;
\end{center}

With traditional C++, if a programmer wanted a constant iterator to the beginning of this map, code will be likely as follows:

\begin{center}
std::map$<$std::string, std::vector<unsigned int$>>$::const\_iterator iter = mv.begin();
\end{center}

However, the auto keyword can be placed instead of this complicated and long type to achieve the same purpose. Additionally, it makes code easier to understand and save a programmer's time, as follows:

\begin{center}
auto iter = mv.begin();
\end{center}

Code of achieving that can be shorter and more robust when a programmer use auto keyword within range-based for statement (which added by C++11), instead of for loop to accomplish the same result \ref{AutoKeyword_MapContainer}. The auto keyword can also be placed instead of class template std::initializer\_list (which added by C++11), to declare an object of the same type in easy way \ref{AutoKeyword_InitializerList} \cite{Gregorie:professionalcpp}.
\newline

The use of keyword has significant role to support generic programming, particularly, template classes. It deduce the type of a variable  during compile- time that depends critically on template argument in such easy way that could not be figure out by a programmer \ref{AutoKeyword_Template} \cite{Stroustrup:2012:Cpp11}.
\newline

The auto keyword has another different usage when it appears with alternative function syntax, which added by C++11. It indicates that function prototype is using alternative function syntax \ref{AlternativeFunction_Syntax}. It could also be served as a place holder for the return type that is deduced or provided later by the alternative function syntax \ref{AlternativeFunction_Template} \cite{Prata:2012:Cpp}.
\newline

The auto keyword is widely used with lambda function, which also added by C++11. As return type of lambda functions is not specified int many cases, the auto keyword uses to deduce return type of function properly, depending on expression that used as return type \ref{Lambda_ImplicitReturn} \cite{Gregorie:professionalcpp}.

% Decltype
\section{Type inference – Decltype keyword}
\label{section: Decltype keyword}
C++11 introduces another new type inference called decltype (declared type), which is used to determine the type of an expression at compile-time. The decltype keyword takes as argument an expression, and returns the type associated with that expression \cite{Stroustrup:2012:Cpp11}. 
\newline

The decltype keyword can be used to create different data types depending on an expression that has been used as argument.  If expression is a variable without parenthesized, then the data type will be the same as the expression type \ref{DecltypeKeyword_Variable}. If expression is lvalue (which mean that variable with parenthesized), then the data type will be a reference to that expression type \ref{DecltypeKeyword_lvalue}. Finally, if expression is function call, the data type will be the same as function return type \ref{DecltypeKeyword_Function} \cite{Prata:2012:Cpp}.
\newline

The decltype keyword is pretty useful to deduce type for combination of expressions that could not known by a programmer. This could happen in generic programming, particularly, template classes because the data type is not defined until compile-time. Thus, the decltype keyword allows compiler to go through a check-list to determine the type of expression \ref{DecltypeKeyword_Template} \cite{Stroustrup:2012:Cpp11}.
\newline

The benefit of decltype keyword can also be shown, when it uses as return type for alternative function syntax (which added by C++11) because a return type is not specified in this type of function within templates. Thus, decltype is used as return type to deduce the type from the context of expression \ref{AlternativeFunction_Template} \cite{Gregorie:professionalcpp}. 

% alternative function
\section{Alternative function syntax}
\label{section: Alternative function syntax}
A function syntax that was designed for C language, is yet using by traditional C++. This old syntax raises some problems and cannot be quite enough for new functionality that has been added to C++11, including deducing return type in the context of declaration \cite{Gregorie:professionalcpp}.
\newline

C++11 introduces a new syntax for declaring functions using a different method to the one that is traditional in C and C++. This notation is known as alternative function syntax, and involves placing the return type at the end of the function signature instead of at the start. Additionally, the auto keyword is placed at the start for the name of the return type, indicating that the prototype is using the alternative function syntax \ref{AlternativeFunction_Syntax} \cite{Gregorie:professionalcpp}.
\newline

Alternative function syntax can be used with decltype keyword to use "this pointer”, which is not otherwise allowed. This is pretty useful with Standard Library container such as vector, to return the first and last value that is pointed by this pointer \ref{AlternativeFunction_This} \cite{ISO:2011:Cpplanguage}. 
\newline

Moreover, using the combination of alternative function syntax and the decltype keyword within templates, solve important problems that could face a programmer, particularly, when a return type is not known exactly.  Consider this situation, when template has two different types, and return type will be the combination of these types, as following:
\begin{center}
template $<$class T1, class T2$>$  ?type? add (T x, U y) 
\newline

\{ return x+y; \}
\end{center}

As it is shown, a type of adding x and y are not known in advance by a programmer. Using the decltype (x + y) alone for return type to address this issue, will cause compiler error, because x and y at the beginning of prototype, are not known.  In other words, they are not in scope, as follows:

\begin{center}
template $<$class T1, class T2$>$  decltype( x + y ) add(T x, U y)
\newline

\{ return x+y; \}
\end{center}

The benefit of alternative function syntax can be gained here by allowing the return type (decltype(x + y)) is specified after the parameter list. Hence, x and y are in the scope and can be used by decltype to deduce return type \ref{AlternativeFunction_Template}. As a result, alternative function syntax and decltype keyword are very useful in the context of specifying the return type of template functions, when a return type is not well known by a programmer\cite{Prata:2012:Cpp}.
\newline

alternative function syntax is not mainly about templates and type deduction, but also about the scope.  With this new syntax, when the scope is written to define function within class, there is no need to add it again to return type because return type goes at the end of the function. Thus, a compiler can reach the return value as it already knows the function is part of class \ref{AlternativeFunction_Scope} \cite{Allain:2011:FutureCpp}.

% Range-based for statement
\section{Range-based for statement}
\label{section: Range-based for statement}
C++ supports three types of looping structures namely while loop, do while loop and for loop. In some cases, such iterating over the elements of Standard Library containers including vector and map requires a lot of codes to accomplish iteration properly. Because using these types require create a new variable to store the iterators, and then dereference the iterators using the * operator to get the actual value, as well as initializing the beginning and ending conditions in these forms of loops \cite{Horstmann:2008:BC}.
\newline

C++11 adds a fourth way of looping called the range-based for statement that allows for easy iteration over elements of a list. Range based-for statement is useful technique for writing less code and getting less errors, and can be used with C-style arrays \ref{RangeFor_Array}, initializer lists \ref{RangeFor_InitializerList} and Standard Library containers, that have begin () and end () functions such vector \ref{RangeFor_Vector}. 
\newline

Range based-for statement is much easier to read and understand, and saves programming effort because it does not require initialize the beginning and ending conditions \cite{Overland:2011:CWF}.
\newline

Generally, Range based – for statement comes in two forms: first one is:
\begin{center}
For (base\_type  variable : container)
\end{center} 

This is used to deal with elements of list by value. Thus, the contents of a list cannot be modified \ref{RangeFor_InitializerList}. The second one is:
\begin{center}
For: (base\_type\& variable: container).
\end{center}

This uses reference to be able for modifying the contents of list \ref{RangeFor_Array}.
\newline

The range-based for statement also supports the notion of uniform initialization, for instance, a programmer can simply print a lot of numbers by using this form of loop with brace-initialization. \ref{RangeFor_UniformInitialization} \cite{Overland:2011:CWF}.

% Lambda Expression
\section{Lambda Expressions}
\label{section: Lambda Expressions}
Traditional C++ includes useful generic functions such as std::for\_each and std::transform, which can be very handy to deal with Standard Library algorithms.  Unfortunately, they can also be quite cumbersome to use, particularly if a functor (functors also called function object, are objects that can be handled though they are a function or function pointer, they are declared by defining member function operator () in class), that would be used as predicates for STL algorithms, are unique to the particular function, because using functor once in specific place seems overkill to be writing whole class just do something trivial and one off \cite{Allain:2011:FutureCpp}. 
\newline

Another reason is that, the function that used by C++ programmers, has C style that  allow each function name to do specific purpose in a program, meaning it must be written separately for each various usage.
\newline

C++11 introduces a new feature called lambda expression (also known as a lambda function) that can be created almost everywhere. Lambda expression considers one of the most exciting features due to its ability to create anonymous functions inline in a source code and greatly simplify it, rather than writing a separate function or a function object.  Thus, the ability of creation functions become quicker and easier, and the code can be easily understood \cite{Gregorie:professionalcpp}.
\newline

This notion may seem a bit weird to those only familiar with the C family of languages, but this is a fairly common feature of most programming languages such as C\#, PHP, JavaScript and Haskell.  
\newline

The syntax of lambda expression can be demonstrated in different styles, depending on purpose that should be achieved. Basically, the general syntax is as follows:
\begin{center}
[capture\_block](parameters) mutable exception\_specification -$>$ return\_type {body}
\end{center}

A lambda expression contains the following parts:
\begin{enumerate}
\item \textbf{Capture block:} this determines how variables (from outside-global variable or inside-local variable) are captured from the enclosing scope, and then make them being available to use inside the function body. there are two methods for capturing all variables from enclosing scope:

      \begin{enumerate}
      \item $[$=$]$ means that a compiler captures all variables by value \ref{Lambda_Mutable}.
      \item $[$\&$]$ means that a compiler captures all variables by reference 
             \ref{Lambda_FunctionParameter}.
      \end{enumerate}
      However, leaving the capture block empty [], tells a compiler not to capture nothing from the enclosing scope \ref{Lambda_Invocation}. \\
      It is also possible to capture variables using both reference and value. This can be done by selectively determine which variables are being captured by reference and then using $[$\&$]$ in front of them. Then, the rest are being captured by value $[$=$]$ as a default capture \cite{Gregorie:professionalcpp}.The default capture must be the first element in the capture list as follow:
      \begin{enumerate}
      \item $[$=, \&a, \&b$]$, capture a and b by reference and the rest by value by default \ref{Lambda_Foreach}.
      \item $[$\&, a$]$, capture by reference by default, except a by value.
      \end{enumerate}
      
      
\item \textbf{Parameters:} : It can be represented by a list of parameters that are used for the lambda expression \ref{Lambda_ExplicitReturn}. This list is optional and can be omitted, if a programmer does not need any parameters for the lambda expression and not specify mutable, nor exception specification and return type \ref{Lambda_Invocation}. The list of parameters in the lambda expression is similar to that in the normal functions, except some restrictions including parameters cannot have default values, unnamed parameters are not allowed and variable length argument lists are not allowed \cite{Cppreference:2012:Cpp11}.

\item \textbf{Mutable:} When variables from the enclosing scope are captured by value, a copy of which will become available inside the lambda expression. By default, those copies are considered as const copies, meaning lambda body cannot modify the value of those copies. If mutable option is inserted to the lambda expression, those copies are become non-const and then can be modified \ref{Lambda_Mutable} \cite{Cppreference:2012:Cpp11}.

\item \textbf{Exception\_specification:} This is optional and uses to determine which exceptions can be thrown by the body of the lambda expression.

\item \textbf{Return\_type:} It is used to specify the type of the returned value such as std::string \ref{Lambda_ExplicitReturn}. This is optional, and If it is not provided, a compiler will decide implicitly the return type according to expression that used for return type \ref{Lambda_ImplicitReturn}, otherwise the return type is considered void \ref{Lambda_Invocation} \cite{Cppreference:2012:Cpp11}.
\end{enumerate}

As a result, a program may not include all these options because they are primarily dependent on a programmer's intend to accomplish specific purpose.
\newline

The lambda expression can be used to print simple string without having any parameters and return type. This can be achieved by parentheses () at the end of the lambda body, which causes to execute the lambda expression immediately \ref{Lambda_Invocation}. It is also possible to store pointer to lambda expression and execute it by the function pointer \ref{Lambda_PointerFunction} \cite{Gregorie:professionalcpp}.
\newline

\subsection{Lambda Expressions as Return Type}
\label{subsection: Lambda Expressions as Return Type}
Std::function$<>$ class template, defined in the <functional>, is polymorphic function object wrapper and is considered one of the great new features that introduced by C++11, due to its ability to wrap to callable objects ( function pointers, function object and lambdas) as long as there is compatibility in terms of argument  and return type with those of the wrapper.
\newline

Therefore, the new std::function is an extremely useful way for passing around lambda functions as return values and by doing that, lambda expressions can be returned from ordinary functions. \ref{Lambda_FunctionReturnType} \cite {Josuttis:2012:CppStandard Library}.
\newline

\subsection{Lambda Expressions as Parameters}
\label{subsection: Lambda Expressions as Parameters}
The std::function can be also used to pass around lambda expression as parameters. Thus, it is possible to defining ordinary functions that take lambda expression as parameter to implement callback functions \ref{Lambda_FunctionParameter} \cite{Allain:2011:FutureCpp}.
\newline

Using lambda expression as parameters has significant impact over Standard Library algorithm and without doubt, it is the biggest beneficiaries of lambda expressions, because previously, using algorithms such as std::sort and std::for\_each require writing separate code to accomplish their purposes. But now, lambda can be placed as third parameter to achieve the same purpose, without writing separate functions \ref{Lambda_Foreach}, \ref{Lambda_Sort} \cite {Gregorie:professionalcpp}.
\newline

As a result, lambda expression is significant step forward, and improves code clarity and makes programming easier.

% Delegating Constructors
\section{Delegating constructors}
\label{section: Delegating constructors}
C++ does not furnish a mechanism by which one constructor is able to delegate another constructor in the same class.  As a consequence, the default arguments cannot be used by class's constructor (s) for initializing class members. Therefore, classes should provide multiple constructors, each with a distinct parameter(s). Those constructors may often execute similar initialization operations, and this leads to force a programmer to duplicate same pieces of code in each constructor as well as duplication in object level \cite{Overland:2011:CWF}.
\newline

In addition to that, Other Object Oriented languages, such as Java, permit constructor to delegate another of the class's constructor(s).  As Java is often used as educational and basic language, increasing C++ newcomers with prior experience of Java are often find substantial differences between these languages. Hence, huge mistake could happen when attempting to write C++ code as same as Java's behaviour \cite{Overland:2011:CWF}.
\newline

C++11 provide mechanism of delegating constructor, which permit constructor to call another constructor from the same class. This feature allows a programmer to define general and desirable initializations in one constructor dubbed target constructor, which can be called by delegating constructor to do the initialization. Delegating and target constructor are presented in the same interface as other constructors do. Target constructors do not require particular treating to become the target of a delegating constructor. In fact, they are chosen by overload resolution \cite{Overland:2011:CWF}.
\newline

When the execution of target constructor is completed, controls get back to the delegating constructor. A delegating constructor can also be used as the target constructor for one or more delegating constructors but a programmer should be aware about a recursive chain of delegation which could lead to compiler error \cite{Overland:2011:CWF}.
\newline

Delegating constructors makes writing overloaded constructors easier and without duplicating the common code. It also makes programs more readable and maintainable that may lead to decrease the chance of error \ref{DelegatingConstructor} \cite{Overland:2011:CWF}.

\section{Override keyword}
\label{section: Override keyword}

\section{Final keyword}
\label{section: Final keyword}


% Null pointer constatn
\section{Null pointer constant}
\label{section: Null pointer constant}
C++ language has the pre-processor macro called NULL, which was used with a pointer to refer that it is not pointing to anywhere. The problem with NULL is that, underneath it is just a plain 0. 
\newline

This raise some problems, for instance, consider a situation when a programmer defines two functions with the same name and one has int argument and other has a pointer argument. Then, calling the function with NULL parameter cause cease a program, because it cannot decide if NULL is actually a pointer (because it is a 0) or an integer (because NULL is a 0). Thus, this ambiguity causes a compiler error \cite{Cppreference:2012:Cpp11}.
\newline

C++11 solves this problem by introducing nullptr keyword, which is a null pointer constant that unambiguously represents a pointer pointing to nowhere; no zero at all. It considers a strongly typed null pointer and can be passed as a null pointer to a function without ambiguity \ref{NullPointer} \cite{Cppreference:2012:Cpp11}. 


% Enumerations
\section{Strongly typed enumerations}
\label{section: Strongly typed enumerations}
Enumerations of traditional C++ are not type-safe, and have some problems may cause catastrophic when used in life-critical software. One of these problems is implicit conversion between types. Although enumerations in C++ have some type safety features including preventing directly assign from one enumeration type to another and not implicit conversion from an integer to enumeration type, but the value or object of an enumerator is allowed to convert implicitly to integer.
\newline

Another problem is that, the underlying type of an enum cannot be specified explicitly by programmers. Therefore, it cannot be determined how much space will be used by the representation of an enumeration variable. Finally, enumerations in C++ are not strongly scoped and could raise some issues such as conflict can happen when two enumerations have enumerators with the same name in the same cope\cite{Stroustrup:2012:Cpp11}.
\newline

C++11 provides a new form of enumeration which combining enum with class and is declared by using keyword enum class and is used to handle the problems that existed in traditional C++.  Implicit conversions to or from an integer is not allowed in this type and any attempt doing that cause a compiler-error \ref{EnumerationClass_Implicit} \cite{Overland:2011:CWF}.
\newline

The underlying type of enum class is clearly specified, by default is integer.  A programmer can explicitly specify another type by writing type following the enumeration name \ref{EnumerationClass_Explicit}. C++11 Enumerations have class scope for their enumerators. This eliminates a possible source of name conflicts between enumerators from different enum definitions \ref{EnumerationClass_Conflict} \cite{Josuttis:2012:CppStandard Library}.


\section{Explicit Conversion Operators}
\label{section: Explicit Conversion Operators}

% Alias templates:
\section{Alias templates}
\label{section: Alias templates}
The type alias is mechanism that allows a programmer to create an alias, or synonym, for an existing data type, without creating new type.  This technique is useful to simplify declarations that could be widely used in a program and documenting it.
\newline

Traditional C++ supports this technique by using typedef keyword, which has syntax as follows:
\begin{center}
 typedef $<$the real data type$>$ $<$the alias identifier name$>$
\end{center}

The typedef keyword is pretty useful to provide suitable names when the real type declarations become complex to express. This could happen when dealing with Standard Library containers and templates. Thus, it reduces the amount of code necessary \cite{Gregorie:professionalcpp}.
\newline

However, using typedef keyword with template require specifying concrete types for each template type and this restricts a programmer to specify each parameter type explicitly in a program. Otherwise, it is not valid. In addition, using typedef keyword becomes complicated with function pointers and makes a code hard to read by ordinary programmer \ref{TypeAlias_FunctionPointer} \cite{Gregorie:professionalcpp}.
\newline

C++11 introduces a new mechanism for declaring type aliases called template aliases, that is applied by "using" keyword.  Template aliases make writing the code easier than the old typedef, and less error prone. They have straightforward syntax as follows that make a program easier to understand.

\begin{center}
using $<$the alias identifier name$>$ = $<$the real data type$>$
\end{center}

Template aliases can be used as the same as the typedef to create type aliases for variables \ref{TypeAlias_Varialbe}. They can also be declared as a pointer to function with a straightforward syntax, instead of declaring a pointer in the middle of syntax as exist in the old style \ref{TypeAlias_FunctionPointer} \cite{Gregorie:professionalcpp}.
\newline

Template aliases remove the limitations that exist with the old typedef in terms of dealing with templates. They allow a programmer to define type aliases for templates without concrete types, and give flexibility to the programmer to specify the type when an object is declared \ref{TypeAlias_Template} \cite{Gregorie:professionalcpp}.
\newline

Hence, type aliases are useful to make a code easier to read by having simple syntax and also provide flexibility to deal with a code.

\section{Conclusion}
\label{section: conclusion}


% Functionalit Improvements
\chapter{Core Language Functionality Improvements}
\label{chapter: Functionality Improvements}

\section{Introduction}
\label{section: Introduction}

\section{New character types : char16\_t and char32\_t}
\label{section: char16_t and char32_t}
The C++ language has extended a support character set over the last years. This included wide character (wchar\_t), which is a significant step forward because it has led to raise the amount of space usable to define a single character. In wide character sets, available space is used exactly as ASCII, each a number represents a special glyph, but the difference is that each number does not represent in 8 bits. The form of characters to numbers (now dubbed code points) is larger than it was, because it deals with lots of different sets in addition to the characters that are familiar by native English programmers \cite{Gregorie:professionalcpp}.
\newline

Both of Unicode Consortium and the Universal Character Set (UCS) that defined by the International Standard ISO10646, are standardized sets of characters. They include approximately 100000 abstract characters, and each defined by special name and an integer number named its code point. Both standards contain the same characters and their associated numbers and have particular encodings that could use by programmers. For instance, UTF-8 (which is stands for Unicode Transformation Format -8) is an example of a Unicode encoding, which use 8-bit blocks to encode a character. The number of blocks required to encode a character varies from one to four bits.  UTF-16 and UTF-32 encoded Unicode characters as one or two 16-bit values, and as exactly 32 bits, respectively \cite{Gregorie:professionalcpp}.
\newline

Different encodings could be used by different applications. Unfortunately, wide character (wchar\_t) that introduced by C++, was not enough, because the size of wchar\_t can change from one implementation to another. For example, on Windows it is 16 bits, whereas on other operating system could be 32 bits \cite{Gregorie:professionalcpp}. 
\newline

To address this issue, C++11 comes with two new types char16\_t and char32\_t, which use to store 16 and 32 bits respectively. They can be used as the basic building block for UTF-16 and UTF-32 encoded Unicode characters \cite{Josuttis:2012:CppStandardLibrary}.
\newline

C++11 use the “u” prefix to represent a character literal of type char16\_t and ensuring its value equal to its ISO 10646 (and Universal Character Set) code point value, that is represented in a single 16-bits \ref{NewCharacterType_char16}. It also uses the same prefix to represent string constants in 16-bits form \ref{NewCharacterType_String16} \cite{Josuttis2012:CppStandardLibrary}.
\newline

Similarly, the "U" prefix is used to represent a character literal \ref{NewCharacterType_char32} and string constants in 32-bits form \ref{NewCharacterType_String32}.  Supporting for Unicode by C++11 is not only limited over these two types. The UTF-8 is also supported and can be represented by using the “u8” prefix in front of string, indicating that the contents of string are stored in UTF-8 \ref{NewCharacterType_UTF-8} \cite{Josuttis:2012:CppStandardLibrary}.
\newline

Unicode Characters for universal languages are also supported in these new characters types. Thus, it is possible to writing a string, for example, in Arabic language because each character has unique name and number \ref{NewCharacterType_Languages} \cite{Josuttis:2012:CppStandardLibrary}.
\newline

In these types of strings, adjacent string literals concatenate if they have the same encoding-prefix and thus, leading to a single concatenated string literal with that encoding-prefix. This can be also applied when on string literal has not encoding-prefix, it handle as a string literal of the same encoding-prefix as the other operand \ref{NewCharacterType_String16}, \ref{NewCharacterType_String32}, \ref{NewCharacterType_UTF-8} \cite{ ISO:2011:Cpplanguage}.


% Raw string literals
\section{Raw string literals}
\label{section: Raw string literals}
Recently, C++ gained popularity by dealing with markup languages including XML and HTML as well as regular expressions that added by C++11 to the Standard Library to express patterns to be matched against strings. However, this has raised several problems for programmers including a difficulty to writing plethora of backslashes correctly and impenetrable to read, because the same backslash escape sequence is used by regular expressions and C++ in string literals. Additionally, quotation marks and newlines are widely used by mark-up languages, leading escape sequences in string literals are difficult to process, error-prone and cumbersome as well as breaking a string into multiple lines of code is not allowed in C++ \cite{ISO:2011:Cpplanguage}.
\newline

C++11 comes with new concept called raw string literals that does not process escape sequences like $\backslash$t and $\backslash$n as C++ does, instead, as normal text. Raw literal is a string literal with R prefix and has format R "d-char-sequence(r-char-sequence) d-char-sequence". Meaning that, d-char-sequence (delimiter sequence) could be any symbol such as (-, “(), ~) or text (delimiter) and it is considered optionally. Delimiter sequence must be the same at the starting and at the end of the raw string and can be up to 16 characters. The r-char-sequence is the actual raw string, which can represent text, symbols, escape sequences and quotation marks easily \cite{Gregorie:professionalcpp}.
\newline

Raw string is significantly useful in terms of regular expressions. It offers sophisticated and easy way to represent backslashes and other symbols that could use to express specific patterns against sequences of characters \ref{RawString_Backslash}.
\newline

Raw string is also used to represent easily quotation marks and escape sequence, which are massively used by XML and HTML languages \ref{RawString_EscapeSequence}. Thus, it allows for much more sophisticated string handling with less error-prone such as representing whole code of HTML, without any restriction \ref{RawString_HTML}.
\newline

Raw string literals can be combined with Unicode literal prefixes  (“u8”,"u" and "U") to represent the content of raw string in 16 and 32-bits \ref{RawString_UnicodeliteralPrefix} \cite{Gregorie:professionalcpp}.

\section{User-defined literals}
\label{section: User-defined literals}

\section{Explicitly Defaulted special member functions}
\label{section: Defaulted special member functions}

\section{Explicitly Deleted special member functions}
\label{section: Deleted special member functions}

\section{Unsigned long long (int) and long long (int)}
\label{section: Unsigned and long long (int)}

\section{Static assertion}
\label{section: Static assertion}

\section{Variadic template}
\label{section: Variadic template}

\section{Conclusion}
\label{section: conclusion}

% References
\addcontentsline{toc}{section}{Bibliography}
\bibliographystyle{alpha}
\bibliography{Bibliography}	


\begin{appendix}

\chapter{Program Code}
\label{chapter:Programcode}


\section{MakeFile}
\label{Makefile}

\Make

\lstinputlisting{../Makefile.}
\newpage


% Core language Runtime Performance Enhancements
\section{Core Language Runtime Performance Enhancements}
\label{Appendix: corelanguage runtime performance}

\Cpp

\subsection{RvalueReference\_Basic.cpp}
\label{sub:RvalueReference_Basic}
%\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Basic.cpp}


% Core Language Usability Enhancements
\section{Core Language Usability Enhancements}
\label{Appendix: corelanguage usabiliy enhancements}

\Cpp

% Auto keyword
\subsection{AutoKeyword\_Variable.cpp}
\label{AutoKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Variable.cpp}

\subsection{AutoKeyword\_ConstVolatile.cpp}
\label{AutoKeyword_ConstVolatile}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_ConstVolatile.cpp}

\subsection{AutoKeyword\_NewExpression.cpp}
\label{AutoKeyword_NewExpression}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_NewExpression.cpp}

\subsection{AutoKeyword\_Function.cpp}
\label{AutoKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Function.cpp}

\subsection{AutoKeyword\_MapContainer.cpp}
\label{AutoKeyword_MapContainer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_MapContainer.cpp}

\subsection{AutoKeyword\_InitializerList.cpp}
\label{AutoKeyword_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_InitializerList.cpp}

\subsection{AutoKeyword\_Template.cpp}
\label{AutoKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Template.cpp}

% Decltype keyword
\subsection{DecltypeKeyword\_Variable.cpp}
\label{DecltypeKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Variable.cpp}

\subsection{DecltypeKeyword\_lvalue.cpp}
\label{DecltypeKeyword_lvalue}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_lvalue.cpp}

\subsection{DecltypeKeyword\_Function.cpp}
\label{DecltypeKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Function.cpp}

\subsection{DecltypeKeyword\_Template.cpp}
\label{DecltypeKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Template.cpp}

% alternative function syntax
\subsection{AlternativeFunction\_Syntax.cpp}
\label{AlternativeFunction_Syntax}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Syntax.cpp}

\subsection{AlternativeFunction\_This.cpp}
\label{AlternativeFunction_This}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_This.cpp}

\subsection{AlternativeFunction\_Template.cpp}
\label{AlternativeFunction_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Template.cpp}

\subsection{AlternativeFunction\_Scope.cpp}
\label{AlternativeFunction_Scope}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Scope.cpp}

% Ragne-based for statement
\subsection{RangeFor\_Array.cpp}
\label{RangeFor_Array}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Array.cpp}

\subsection{RangeFor\_InitializerList.cpp}
\label{RangeFor_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_InitializerList.cpp}

\subsection{RangeFor\_Vector.cpp}
\label{RangeFor_Vector}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Vector.cpp}

\subsection{RangeFor\_UniformInitialization.cpp}
\label{RangeFor_UniformInitialization}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_UniformInitialization.cpp}

% Lambda Expression
\subsection{Lambda\_Mutable.cpp}
\label{Lambda_Mutable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Mutable.cpp}

\subsection{Lambda\_FunctionParameter.cpp}
\label{Lambda_FunctionParameter}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionParameter.cpp}

\subsection{Lambda\_Invocation.cpp}
\label{Lambda_Invocation}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Invocation.cpp}

\subsection{Lambda\_Foreach.cpp}
\label{Lambda_Foreach}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Foreach.cpp}

\subsection{Lambda\_ExplicitReturn.cpp}
\label{Lambda_ExplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ExplicitReturn.cpp}

\subsection{Lambda\_ImplicitReturn.cpp}
\label{Lambda_ImplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ImplicitReturn.cpp}

\subsection{Lambda\_PointerFunction.cpp}
\label{Lambda_PointerFunction}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_PointerFunction.cpp}

\subsection{Lambda\_FunctionReturnType.cpp}
\label{Lambda_FunctionReturnType}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionReturnType.cpp}

\subsection{Lambda\_Sort.cpp}
\label{Lambda_Sort}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Sort.cpp}

% Delegating Constructors
\subsection{DelegatingConstructor.cpp}
\label{DelegatingConstructor}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DelegatingConstructor.cpp}

% Null pointer constant
\subsection{NullPointer.cpp}
\label{NullPointer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/NullPointer.cpp}

% Strongly Typed Enumerations
\subsection{EnumerationClass\_Implicit.cpp}
\label{EnumerationClass_Implicit}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Implicit.cpp}

\subsection{EnumerationClass\_Explicit.cpp}
\label{EnumerationClass_Explicit}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Explicit.cpp}

\subsection{EnumerationClass\_Conflict.cpp}
\label{EnumerationClass_Conflict}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/EnumerationClass_Conflict.cpp}

% Alias Template
\subsection{TypeAlias\_FunctionPointer.cpp}
\label{TypeAlias_FunctionPointer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_FunctionPointer.cpp}

\subsection{TypeAlias\_Varialbe.cpp}
\label{TypeAlias_Varialbe}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_Variable.cpp}

\subsection{TypeAlias\_Template.cpp}
\label{TypeAlias_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/TypeAlias_Template.cpp}



% Core Language Functionality Improvements
\section{Core Language Functionality Improvements}
\label{Appendix: corelanguage functionality improvements}

\Cpp

% NewCharacterType - char16 and char32
\subsection{NewCharacterType\_char16.cpp}
\label{NewCharacterType_char16}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_char16.cpp}

\subsection{NewCharacterType\_String16.cpp}
\label{NewCharacterType_String16}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_String16.cpp}

\subsection{NewCharacterType\_char32.cpp}
\label{NewCharacterType_char32}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_char32.cpp}

\subsection{NewCharacterType\_String32.cpp}
\label{NewCharacterType_String32}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_String32.cpp}

\subsection{NewCharacterType\_UTF-8.cpp}
\label{NewCharacterType_UTF-8}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_UTF-8.cpp}

\subsection{NewCharacterType\_Languages.cpp}
\label{NewCharacterType_Languages}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/NewCharacterType_Languages.cpp}

% Raw string literals
\subsection{RawString\_Backslash.cpp}
\label{RawString_Backslash}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_Backslash.cpp}

\subsection{RawString\_EscapeSequence.cpp}
\label{RawString_EscapeSequence}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_EscapeSequence.cpp}

\subsection{RawString\_HTML.cpp}
\label{RawString_HTML}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_HTML.cpp}

\subsection{RawString\_UnicodeliteralPrefix.cpp}
\label{RawString_UnicodeliteralPrefix}
\lstinputlisting{../CoreLanguage/FunctionalityImprovements/RawString_UnicodeliteralPrefix.cpp}

\end{appendix}

\end{document}
