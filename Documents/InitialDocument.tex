\documentclass[12pt,a4paper]{report}
\usepackage{graphicx}
\usepackage{cite}

\title{{\Huge C++11 by Examples}}
\date{}

\begin{document}
\maketitle

\begin{center}
\textbf{Dilshad Sallo \\Student Number: 59950\\ Swansea University \\ Under Supervision of Dr. Oliver Kullmann}
\end{center}


\begin{abstract}
\label{Abstract}
C++11 is new standard that released by C++ committee standard representing the effort of most expert in the world. This version includes new features that addresses some limitations that exist in traditional C++ as well as providing new features that never existed in any previous versions. These features support a core language and some libraries and  provide new facilities  to make programming easier than before.\\
The aim of this project is to investigate these features and providing examples to get most out of them and show them as guide to support  novices of all backgrounds.\\
This paper focuses on investigating  features which classify to categories\linebreak depending in which they belong to. Then, it clearly explains the project  specification and requirements which should be mentioned in order to explain how the project will be implemented in the summer. Finally, it should not be forgotten the important part of this report is the time management which assists to arrange the time in the summer.
\end{abstract}

\newpage
\tableofcontents
\newpage

\chapter{Introduction}
\section{Introduction}  
\label{section: intorduction}
C++ is a general-purpose language that is in widespread use for systems and embedded programming. It is a high-level programming language that allows a programmer to efficiently communicate with a computer. C++ fully supports object-oriented programming, including the four pillars of object-oriented development, namely Encapsulation, Data hiding, Inheritance and Polymorphism.\\
Standard C++ consists of three important parts;the core language giving all the building blocks including variables, data types and literals,the C++ Standard Library giving a rich set of functions manipulating files, strings, and the Standard Template Library (STL) giving a rich set of methods manipulating data structures.\\
Due to complexity applications  that required in various fields and evolution of programming that  accompanied by modern technology, some limitations and bugs have discovered in C++ language that have significant impact on programmers of all backgrounds.\\
As responsibility of C++ Standards Committee to address this issue, new standard is released dubbed C++11. It is represented by new features that added to core language, Standard  Library, and Standard Template Library. The purposes of these features are make programming easier by providing simple syntax, providing new style of programming and adding new facilities that never existed in any previous versions. These lead to support novice programmers to write robust codes using efficient style.\\
The goal of this report is showing how these features will be investigated to support novice programmers. They represent by specification that written in formal methods, which represent some categories that  classify depending on features belong to. The report also show requirements of this project which depend on the nature of features. Finally, the report presents the plan which will be implemented in the summer, and this plan consists of stages which implement the software step by step to get in the final form.
\newpage


\section{The purpose of project}
\label{section:The purpose of project}
The aim of this project is to investigate core language  features of new standard (dubbed C++11) carefully, and presenting them as examples for ordinary programmers who have experience in C++, to understanding this new style of programming languages by using them as scientific  catalogue to develop their skills, and shift toward C++11 language.
\newline
On the completion of this project, programmers who use this project, will get confidence to understand core language of  C++11 and use it with elementary applications.

\section{Objectives of project}
\label{section:objectives of project}
In order to achieve the aim of project, multiple objectives should be followed and done correctly,they are:-
 \begin{enumerate}
   \item Complete a search about core language features and their definitions.
   \item Identify cases of usage for each feature  to know its functionality.
   \item Presenting each case by simple example to make understanding of \linebreak programmers easier.
   \item Show all examples as nice catalogue to support ordinary \linebreak programmers.
   \item Complete final report.
 \end{enumerate}       
 
  
\section{History}
\label{section: History}
The history of C++ programming language has begun in 1979, when Bjarne Stroustrup was working on his Ph.D thesis in the Computing Laboratory of Cambridge, University of England. At that time, he had opportunity to work with a language called Simula, which is considered as the first language to support the object-oriented language paradigm. He observed that paradigm of Simula was very useful for software development\cite{StroustrupHistory}.\\
Shortly after that, he started work on "C with Classes” to accomplish his goal, which represent adding object-oriented programming into the C language with respected all its functionality. His language included basic inheritance, inlining functions, classes, default function arguments, and strong type checking as well as including all the features of the C language\cite{StroustrupHistory}.\\
In 1983, the name of C with Classes was change to C++. The ++ operator in the C language refer to incrementing a variable, which gives some understanding into how Stroustrup considered the language. During that time, many important new features added to the language such as  virtual functions, such as function overloading, references with the \& symbol, the const keyword, and single-line comments using two forward slashes\cite{StroustrupHistory}.\newline
In 1985, Stroustrup's reference to the language titled The C++ Programming Language was published. C++ was carried out as a commercial product in the same year though it was not officially standardized. The language was updated again in 1989 to include protected and static members, as well as inheritance from several classes\cite{StroustrupHistory}.
\newline
In 1990, the Annotated C++ Reference Manual was released, at that time, Borland's Turbo C++ compiler was also released as a commercial product. Turbo C++ added some additional libraries, which could have significant impact on C++'s development\cite{StroustrupHistory}.
\newline
In 1998, the C++ standards committee issued the first international standard for C++ ISO/IEC 14882:1998, which would be informally known as C++98. The Annotated C++ Reference Manual has an important influence on the development of the standard.  In addition it was included the Standard Template Library which started its conceptual development in 1979. Due to multiple problems that discovered in 1998 standard, the committee revised it and changed language was dubbed C++0x in 2003\cite{CplusplusHistoryofCpp}.
\newline
In 2005, the C++ standards committee published a technical report (called TR1) detailing several features which expected to add to the latest C++ standard by committee. Later on, the new standard was informally called C++0x.  The first draft for formal comments was produced in September 2008 and then the Final International Draft standard unanimously approved by the ISO C++ committee in 2011. It was formally approved (dubbed C++11)\cite{CplusplusHistoryofCpp}.
\newline
The new C++ standard (C++11) was published in 2011. The Boost library project made a significant effect on the new standard and it also derived some of new modules from other libraries. As the result, some new features included in the new standard, such as regular expression support, atomics support, a standard threading library which never existed in both C and previous C++, a new for loop syntax with similar functionality for foreach loops in other languages, the auto keyword, new container classes and variadic templates\cite{CplusplusHistoryofCpp}. 

\newpage


\chapter{Literature review}

\section{C++}
\label{section: C++}
C++ is most popular language which has important role in the industry, since it use for just about everything such as building compilers and run-times for competing languages, and operating systems like Windows. In addition, it uses in many social web applications such as browse Google’s Chrome and face book \cite{ISO:2011:Cpplanguage}.
\newline
C++ bring together three separate programming categories: the procedural language, represented by C; the object-oriented language, represented by the class enhancements C++ adds to C; and generic programming, supported by C++ templates\cite{Prata:2012:Cpp}.
\newline
One reason that made c++ most popular, is that, object-oriented programming which emphasizes the data rather than procedural programming, which emphasizes algorithms, but with modern applications which use concurrent, distributed programming and complicated codes, programmers need to think differently about system design and implementation as well as using easy syntax  to create robust code.This can be achieved with new standard language C++11\cite{Stroustrup:2012:Cpp11}.

\section{C++11}
\label{section: C++11}
C++11 is the new standard of C++ language. It was known as C++0x until mid- 2011, and then formally published as ISO/IEC 14882:2011. C++11 feels like a new language and a higher-level style of programming more efficient than before\cite{ISO:2011:Cpplanguage}. 
\newline
C++11 provide new facilities(features) which make programming more natural and efficient than before as well as helping programmers to think differently about system design and implementation \cite{Stroustrup:2012:Cpp11}. This is not just for C++ programmers but also for programmers who used to programming with modern languages in general areas. Moreover, it improves abstraction mechanisms and makes it more flexible and safely by using some features together. These features extend the powerful of traditional C++ in terms of flexibility and efficiency as well as enabling programmers to get most benefit of them to write robust codes \cite{ISO:2011:Cpplanguage}.
\newline
C++11 adds many new language features to C++ that should cover some limitation and reduce the overall verbosity of C++ as well as provide new concept, such as lambda expressions, that increase its overall expressiveness and clarity.
\newline
C++11 provides features such as auto keywords to make C++ more usable language as well as features like move semantics to improve the basic efficiency of the language, allowing programmer to write faster code, and the improvement to the template system make it much easier to write generic code\cite{Stroustrup:2005:Cpp}.
\newline
C++11 also adds new features to the standard library which never existed in any previous versions, including adding multi-threading support directly into C++ and improved smart pointers that will simplify memory management. 
\newline
In general, these features have different behaviour, since some features may make programming a little bit difficult because they replace some rules with one more general rule such as uniform initialization,  and inheriting constructors, others easier by providing more flexible features than older version such as auto, array and range-for-statement \cite{Stroustrup:2012:Cpp11}.

	

\section{Boost library}
\label{section: Boost library}
The Boost C++ Libraries are free, open source libraries created by members of the C++ community. Boost provides useful, well-designed libraries that work well with the existing C++ Standard Library. Boost can be used on many platforms with many different compilers. Ten Boost libraries are included in the C++ Standards Committee's Library Technical Report (TR1). These libraries add useful functionality to C++.  C++11 also includes several more Boost libraries in addition to those from TR1, namely, Boost.Array, Boost.Bind, Boost.Function, Boost.Random, Boost.Regex, Boost.Smart\_ptr, Boost.Tuple and Boost.Type\_traits. These libraries consider a part of C++11 and they provide many facilities that support programmers\cite{Deitel:2012:CPP}.


\section{Why C++11?}
\label{secton: Why C++11}
The nature of C++ focus on general features (notably classes) to demonstrate its main strength, while it has main weakness that represent by specialized features (such as threads and properties) are neglected.
\newline
The main goals for C++11 are to make C++ easier to learn, teach, and understand, improve library building capabilities, and increase compatibility with the existing standard C++ and C programming language \cite{Deitel:2012:CPP}.
\newline
In addition, while traditional C++ is not only designed for Windows language or Web language but also for general purpose, C++11 will extend that and support generic programming, concurrent, parallel and distributed programming. 
The new features can save programmers from fading into “dark corners.” and make through less error-prone language features and through more supportive libraries.


\section{Why small and many programs?}
\label{section: why small and many programs}
knowing the syntax of C++11 language is not enough to learn and understand the correct way to use the language, unless providing  simple  programs that give idea to programmers from first glance. This can be achieved by small and many programs that represent features and their usages.


\section{Core Language}
\label{section: core language}
 \begin{enumerate}
\item \textbf{Unsigned long long (int) and long long (int):} in C++, the largest integral type is long int which guarantee to have at least as many  usable bits as int. This type could have 32 or 64 bits, depending on compiler type. The new C++ standard (C++11) introduces the types long long and  unsigned long long to address this issue. They guarantee at least as same range as long int with 64 bits, with any compiler\cite{Gregorie:professionalcpp}.

\item \textbf{keyword Auto:} many programming languages such Java, C and C++ obligate a programmer to specify data type of variables, before initialize  and using them in a program. This not easy to express sometimes, especially, with defined return value of a function or with template. C++11 adds significant feature called auto keyword, which allows a compiler to deduces the type of variables or return value of a function automatically during compile-time. This makes easier to work with other features\cite{Prata:2012:Cpp}.

\item \textbf{Decltype (expr):} C++11 adds the keyword decltype which can be used to determine the type of an expression at compile-time. The decltype specifier is useful mainly to developers who would to write template libraries\cite{Gregorie:professionalcpp}.

\item  \textbf{Enumeration Class:} enumerations in C++ are not type-safe, and causing many problems such as assigning one enumeration type to another is not allowed directly and there is no implicit conversion from an integer value to an enumeration type. In addition, they are not strongly scoped because when two enumerations in the same scope have enumerators with same name, this is illegal. C++11 adds strong type enumeration called enum class which covers these issues. This type does not conflict with any existing enum and also do not support implicit conversation to from integer. The underlying type of enum class is clearly specified, by default is integer, and a programmer can be specify another type by writing type following the enumeration name. Moreover, enum class has the same scope as class to access its own variables\cite{Gregorie:professionalcpp}.
  
\item \textbf{Default method:} using class in a program may leads to some difficulty for a novice programmer, particularly, dealing with constructor. When the programmer does not specify any constructor and he creates object without arguments. A program still works because compiler will write one that does not take any arguments, but defining constructor that takes arguments without define default constructor leads to compiler-error, because default constructor is not defined explicitly. C++11 adds keyword default that allows the programmer to define explicit default constructor and without writing the body of it. This handles this issue and this keyword can also be used with copy constructor and an assignment operator\cite{Gregorie:professionalcpp}. 

\item \textbf{Delete method:} C++11 also supports the concept of explicitly deleted constructors.  A programmer can define classes without any constructors and also prevent compiler to generate default constructor by using keyword delete.  It can also be used to explicitly delete overloaded methods, for instance, suppose that programmer define function called f(), which takes integer value. When calling this function with double value, the compiler will convert the double value to an integer value and then call function f() but it will execute this implicit conversion. To avoid this issue, the keyword delete can be followed a double instance of function f() and then a compiler will be flagged as an error by calling f() with double value\cite{Gregorie:professionalcpp}.
  
\item \textbf{Predeclared identifier:} C++11 adds a predeclared identifier which is used to capture function names as string literals , as well as makes a function name available for use within the function. It is meaningful only in the context of a function\cite{Gregorie:professionalcpp}.

\item \textbf{Rvalue Reference:} In C++, Ivalue can be represented by single variable or persistent object that located on the left- hand side of an   assignment operator. All variables including (const) variables are Ivalue. On the other hand, rvalue defined as anything is not Ivalue, such as temporary object or value and constant value. Normal, an rvalue is on the right- hand side of an assignment operator. 
\newline
C++11 brings new concept called, an rvalue reference, which is used as reference to an rvalue. The purpose of an rvalue, is that, allows some methods (copy constructor and operator = ) can be chosen when a temporary object is involved. Rvalue reference parameter is specified in methods by using \&\& as part of the parameter specification\cite{Gregorie:professionalcpp}. See example RvalueReference1 in Appendix A. 
\end{enumerate}
 
  
 
\chapter{The approach of project}
\section{How does the project achieve?}
\label{secton: how does the project achieve?}
Representing core language features of C++11 can be done by four stages; firstly, understanding the definition of features correctly, secondly, showing complete examples for all features and covering all cases of each feature, thirdly, presenting examples as simple as possible that allow programmers to understand  features easier, and finally, complete and presenting organised catalogue.
\newline
Presenting  examples in this way will  demonstrate the benefit of these features, and what new facilities they offer, as well as showing how these new features solve important problems and how they support ordinary programmers.
\newline
After all features will be shown as examples, they need to be compiled and linked. As the number of files in project grows, the process of compiling and recompiling becomes a real problem, since changing one small file, leading to recompile all programs in project and this may spend few hours.
\newline
UNIX provides significant utility called make. The make utility essentially is used to update targets (exe or object files) according to the dependency instructions, typically present in a file called makefile. The program automatically can link dependent modules and also decide which files are to be (re)compiled by looking at the object code timestamps. Essentially make allows the compilation process to be a breeze.
\newline
Therefore, specific Makefile is used to compile examples in this project. It contains all the dependency information required for compiling examples in this project.



\section{Classification of features}
\label{subsection: overview of features}
C++11 standards is represented by many new features that included in traditional C++ by the committee standard as effort of most expert in the world. These features added  to core language, Standard Library and Standard Template Library. In addition, C++11 includes additional library that added by Boost library and thread library. The list below represent all features which arranged according to standard C++ :-

\subsection{Core Language}
\label{sub-section: Core language}
\begin{enumerate}
\item Long long int.
\item Unsigned long long int.
\item Char32\_t.
\item Char64\_t.
\item User-defined literals.
\item Decltype.
\item Auto.
\item Enumeration class.
\item predefined variable \_\_f\_\_.
\item null pointer constant.
\item range-based for statement.
\item Uniform initialization.
\item Right angle bracket.
\item Lambda.
\item Constexpr.
\item Type Alias.
\item static\_assert.
\item Alignof and Alignas.
\item Rvalue reference.
\item Unrestricted unions.
\item Alternative function syntax.
\item Explicit Conversion Operators.
\item Override keyword.
\item Final keyword.
\item Explicit Defaulted.
\item Explicit deleted.
\item Initializing  members.
\item Move semantic.
\item Inheriting constructors.
\item Delegation constructor.
\item Extern template.
\item Variadic templates.
\item noexcept keyword.
\end{enumerate}


\subsection{Language support library }
\label{Language support library }
\begin{enumerate}
\item Initializer\_list.
\end{enumerate}



\subsection{General utilities library}
\label{sub-section:General utilities library}
\begin{enumerate}
\item Pairs $<$utility$>$.
\item Tuples $<$tuple$>$.
\item Smart pointers $<$memory$>$.
\item Type Traits $<$type\_traits$>$.
\item Compile-time rational arithmetic $<$ratio$>$.
\item Time utilities $<$chrono$>$.
\item Time utilities $<$ctime$>$.
\end{enumerate}



\subsection{Containers library}
\label{sub-section:Containers library}
\begin{enumerate}
\item Sequence containers $<$array$>$.
\item Sequence containers $<$forward\_list$>$.
\item Associative containers $<$map$>$.
\item Associative containers $<$set$>$.
\item Unordered associative containers $<$unordered\_map$>$. 
\item Unordered associative containers $<$unordered\_set$>$. 
\end{enumerate}

\subsection{Numerics library}
\label{sub-section: Numerics library}
\begin{enumerate}
\item Random number generation $<$random$>$.
\end{enumerate}

\subsection{Regular expressions library}
\label{sub-section: Regular expressions library}
\begin{enumerate}
\item Regular expression template $<$regex$>$.
\end{enumerate}

\subsection{Atomic operations library}
\label{sub-section:	Atomic operations library}
\begin{enumerate}
\item Atomic Types $<$atomic$>$.
\end{enumerate}

\subsection{Thread Library }
\label{sub-section: Thread library }
\begin{enumerate}
\item Threads $<$thread$>$.
\item Mutual exclusion $<$mutex$>$.
\item Condition variables $<$condition\_variables$>$.
\item Future $<$futhre$>$.
\end{enumerate}


\section{The structure of achievement  the project}
\label{section:The structure of achievement  the project}
Due to existence many new features, this project will not cover all features, instead, it will investigate features that belong to the core language, because they are widely used by ordinary programmers.  Moreover, these features offers new facilities such simple syntax and make programming easier, which help programmers to write robust elementary applications.
\newline
At present, there is no compiler to support all new C++11 features. Therefore, most of features can be compiled in Microsoft Visual C++2010 and GCC compiler.At the moment,  GCC 4.5.3  compiler will be used to investigate features and later GCC 4.7.0 will be used to do that, because it supports more features than previous version does.
\newline
The core language features can be classified into four general sections, in terms of investigation, namely; run-time performance enhancements, build-time performance enhancements, usability enhancements, and functionality improvements. Some features may have more than one cases and this project will cover as many as possible according to their importance.
\newline

\subsection{Core language time performance enhancements}
\begin{enumerate}

\item \textbf{Rvalue reference:} C++11 Standard introduces rvalue references, which bind only to rvalues, not
to lvalues, and are declared with two ampersands rather than one. This can be referenced to const and temporary. It can be also used with move semantic. Programs should show how this concept apply with constant and temporary object as well as using it with move semantic.

\item \textbf{Move semantic:} C++11 includes a new concept called move semantics, which requires a move constructor and move assignment operator. It also uses to force compiler to convert from Ivalue to rvalue. These concepts should be demonstrated by simple examples to make them easier to understand.

\item \textbf{constexpr:} C++11 introduced the keyword constexpr. The benefit of using constexpr is that the compiler can optimize your code much better during the compilation process. Program should show how a function declare as constexpr and how it can  be applied to objects.
\end{enumerate}


\subsection{Core language build-time performance enhancement}
\begin{enumerate}

\item \textbf{Extern template}:  C++11 introduced extern template declarations, analogous to extern data declarations and this enhance build-time performance. Program should show how this concept use with simple form by using template.
\end{enumerate}


\subsection{Core language usability enhancements}
\begin{enumerate}
\item \textbf{Uniform initialization}: C++11 provides a syntax that allows for fully uniform type initialization that works on any object. This concept can be applied as examples with class and function to show its benefit.

\item \textbf{Auto:} It allows a compiler to deduces the type of variables or return value of a function automatically during compiler-time. This feature can be used with template, alternative function, variables and expression. Programs should demonstrate these all cases.

\item \textbf{Decltype:} C++11 adds decltype keyword which can be used to determine the type of an expression at compiler time. This feature can be used with template, expression and variables. Programs should present this cases.

\item \textbf{Range-based for-loop:} The range-based for loop is a fourth way of looping which has been added to the C++11 standard. It allows for easy iteration over elements of a list. Programs should show how this feature work using auto feature.

\item \textbf{Lambda functions:} It allows programmers to write anonymous functions inline. Programs should show lambda expressions as return type, lambda expressions as parameters and lambda with template.

\item \textbf{Alternative function syntax:} It is new concept of function that introduced by C++11. This feature can be represented by simple example to show syntax of this function as well as using it with template.

\item \textbf{Delegation constructor: } This allows constructors to utilize another constructor's behavior with a minimum of added code. This can be showed by simple example contains two classes.

\item \textbf{Explicit overrides and final:} C++11 adds these features which are used to prevent inheriting and overriding. They can be applied by examples that contain classes to show their functionality.

\item \textbf{Enumeration class:} This type does not conflict with any existing enumeration and also do not support implicit conversation to from integer. Program should clearly show how does not conflict and how does not support implicit conversation.

\item \textbf{Explicit conversion operators:} With C++11, a programmer can use the explicit keyword to prevent the compiler from performing the implicit conversion and this can be showed with simple program that contains class.

\item \textbf{Alias templates:} C++11 adds a new mechanism for creating type aliases, which is easier to understand than the old typedefs in certain situations. Programs should show this concept with template and without it.
\end{enumerate}


\subsection{Core language functionality improvements}
\begin{enumerate}
\item \textbf{Unsigned long long (int) and long long (int):} These types are guaranteed to be at least as large as a long int, and have no fewer than 64 bits. Program should show that they having size of 8 bytes on implementations.

\item \textbf{char16\_t and char32\_t:} These are designed to store UTF-16 and UTF-32 respectively. Program should demonstrate how they store character literals such as u' c-char-sequence', U' c-char-sequence' and string literals as well as escape sequences.

\item \textbf{User-defined literals:} This gives to the user, the ability to create new custom literal modifiers and  user defined literals should start with an underscore and are implemented by writing literal operators. A literal operator can work in raw or cooked mode. Program should show how literal operator will receive a sequence of characters, and cooked mode literal operator will receive a specific interpreted type.

\item \textbf{Explicitly defaulted and deleted:} These keywords give control to a programmer to define default or delete constructor, copy constructor and overloaded operator, Programs should show all these cases.

\item \textbf{Static assertion:} which is an assert that is evaluated at compile time, instead of run time. A program should present by using template.

\item \textbf{Alignof and Alignas:} C++11 allows variable alignment to be queried and controlled with alignof and alignas. Program should show how they use with class and variables.

\item \textbf{Variadic template:} Templates which take a variable number of template parameters. Programs should use this concept with function and variable to present its purpose.
\end{enumerate}



\chapter{Plan}
\section{Plan}
\label{section: plan}

This section will show the time management of the project to ensure that the aims of project will do correctly.  Because of many features need to investigate in specific time, a plan should be used to manage the time in effective way in order to fulfil the purpose of the project without losing time.
\newline
Investigating some cases of some features have been done. Therefore, time management for project period in summer for investigating the rest of features will begin from 15-06-2012 to 30-09-2012 and the investigation will commence from easiest to hardest as follow:

\begin{enumerate}
\item \textbf{Unsigned long long and long long:} One day to understand the definition of these features and write examples for them.

\item \textbf{Char16\_t and char32\_t:} One day to understand the concept of these features and identify their cases. Then, one day to write program that should show character literals, string literals  and escape sequences.

\item \textbf{User-defined literals:} One day to understand the definition of user-defined literals and its usage. Then one day to write programs for a literal operator in raw mode  and cooked mode.

\item \textbf{Delete and default keywords:} One day to understanding the definition and presenting examples to constructor, copy constructor and overloading operator.

\item \textbf{Static assert:} One day to understand the concept of static assert and present example to show its benefit.

\item \textbf{Alignof and alignas:} One day to understand the definition of these features and one day to present them with class and variables.

\item \textbf{Uniform initialization:} One day to understand the concept and its cases. Then one day to apply this concept with class and function as well as showing narrowing.

\item \textbf{Auto:} Three days to understand the definition, its cases and present examples to show how it uses with variables, expressions and templates.

\item  \textbf{range-based for statement:} One day to understand the concept and present it by example.

\item \textbf{Delegation constructor:} One day to apply this concept by a simple example.

\item \textbf{Final and override keywords:} Once day to understand their concept and present them with examples.

\item \textbf{Enumeration class:} Once day to show how this concept prevent conflict.

\item \textbf{Explicit conversion operators:} Two days to understand the definition of explicit conversion operators, and present this concept by suitable example.

\item \textbf{Type alias: } One day to understand this concept. Then, two days to write programs using type alias with and without template.

\item \textbf{Rvalue reference:} One day to understand the definition of rvalue. Then, three days to present this feature with simple examples as well as using with move semantic.

\item \textbf{Constexpr:} One day to understand the concept. Then, three days to write programs that show how using constexpr with function and object.

\item \textbf{Alternative function syntax:} Two days to understand the concept. Then two days to write examples using it with and without template.

\item \textbf{Lambda:} One days to understand the definition of lambda. Then, four days to write programs using it with function and template.

\item \textbf{decltype:} Two day to understand the concept of decltype. Then, three days to write program using it with variables, expressions and template.

\item \textbf{Extern template:} Two days to understand the concept and write program for it.

\item \textbf{variadic templates: } Two days to understand the definition of variadic template. Then, four days to write programs using it with function and present example with variables as arguments.

\item \textbf{Move semantic:} One day to understand the definition and two days to present it with constructor and operator.

\item \textbf{Writing dissertation:} After core language features will be investigated. Thirty  days  will be used to write dissertation. Beginning with abstract, aims and objectives, and then body which describe purpose of each example and how it reflects that. Finally, writing conclusion to summarise project.

\item \textbf{Test project:} last 14 days, the project will be tested by ordinary programmer to show how much it useful for them. Then, the feedback will  be taken in account to improve it.
\newline
\end{enumerate}



\section{Summary}
\label{section: summary}

To sum up, C++11 supports ordinary programmers by offers much more than (old) C++  and  providing new features which have significant role to enhance memory performance, provide flexibility to solve important problems and make C++ language easier to understand. It also not introduce new holes and  ensure to avoiding unsafe facilities that existed in previous version.
\newpage


%References
\addcontentsline{toc}{section}{Bibliography}
\label{References}
\bibliographystyle{alpha}
\bibliography{Bibliography}	

\newpage

\appendix
\chapter{Appendix A}
\section{MakeFile}
\label{Makefile}
.SUFFIXES : \\ \\
.PHONY : all cleanall \\ \\
source\_dir = .\\ 
bin\_dir = bin \\ \\
compilation\_units = \$(wildcard \$(source\_dir)/*.cpp)\\
source\_files = \$(notdir \$(compilation\_units))\\
programs = \$(addprefix \$(bin\_dir)/, \$(source\_files:.cpp=))\\ \\
CXX = g++ \\
standard\_options = -std=c++0x -Wall -pedantic \\ \\
all : \$(programs)\\ \\
\$(programs) : \$(bin\_dir)/\% : \%.cpp \\
\$(CXX) -o \$@ \$(standard\_options) \$(CPPFLAGS) \$(CXXFLAGS) \$ $<$ \\
\newline
cleanall : \\
- rm \$(programs)

\section{CoreLanguage}
\label{Appendix: corelanguage}
\subsection{UnsignedLong.cpp}
\label{Appendix B: unsignedLong}
{\scriptsize unsigned long long (int) takes at least 8 bytes but minimum value is zero.}
\newline
{\scriptsize
\#include $<$iostream$>$ \\
\#include $<$typeinfo$>$ \\
\newline
int main() $\lbrace$\\
  unsigned long long ll = 3316757944182080000;\\
\newline
  std::cout $<<$ "the datatype of " $<<$ ll $<<$ " is " $<<$ typeid(ll).name() $<<$ "." $ <<$ std::endl;
\newline
  std::cout $<<$ "unsigned long long (int) takes " $<<$ sizeof(ll) $<<$ " bytes." $<<$ std::endl;
\newline
$\rbrace$
}
\subsection{Long.cpp}
\label{LongLong}
{\scriptsize Long long (int) takes at least 8 bytes.}
\newline
{\scriptsize
\#include $<$iostream$>$\\
\#include $<$typeinfo$>$\\
\newline
int main() $\lbrace$\\
  const long long ll = 1284800371338750000;\\
\newline
std::cout $<<$ "the datatype of " $<<$ ll $<<$ " is " $<<$ typeid(ll).name() $<<$ "." $ <<$ std::endl;\\
std::cout $<<$ "Long Long (int) takes " $<<$ sizeof(ll) $<<$ " bytes." $<<$ std::endl;\\
$\rbrace$
}

\subsection{Auto.cpp}
\label{Auto}
{\scriptsize Using the auto keyword to deduce the type of a variable from its initializer expression.}
\newline
{\scriptsize
\#include $<$iostream$>$\\
\#include $<$typeinfo$>$\\
\newline
int main() $\lbrace$\\
  const auto i = 7;\\
  const auto j = 7.5;\\
\newline
  std::cout $<<$ "The datatype of  " $<<$ i $<<$ " is " $<<$ typeid(i).name() $<<$ "." $<<$ std::endl;\\
  std::cout $<<$ "The datatype of  " $<<$ j $<<$ " is " $<<$ typeid(j).name() $<<$ "." $<<$ std::endl;
\newline
$\rbrace$
}

\subsection{Decltype.cpp}
\label{Decltype}
{\scriptsize decltype(exp) will define variable j as the same as exp type.
\newline
\#include $<$iostream$>$\\
\#include $<$typeinfo$>$\\
\newline
int main() $\lbrace$\\
  const int i = 7;\\
  const decltype(i) j = 8;\\
\newline
  std::cout $<<$ "The datatype of  " $<<$ j $<<$ " is " $<<$ typeid(j).name() $<<$ "." $<<$ std::endl;
\newline
$\rbrace$
}
\subsection{Enumeration.cpp}
\label{Enumeration}
{\scriptsize 
Enumeration class allow to define clear underlying type and explicit scope.\\
\newline
\#include $<$cassert$>$\\
\newline
enum class Enum : unsigned long $\lbrace$\\
  e1,\\
  e2 = 10,\\
  e3\\
$\rbrace$;\\
\newline
int main() $\lbrace$\\
\newline
 assert(Enum::e1 == (Enum) 0);\\
 assert(Enum::e2 == (Enum) 10);\\
 assert(Enum::e3 == (Enum) 11);\\
$\rbrace$
}
\subsection{DefaultConstructor.cpp}
\label{DefaultConstructor}
{\scriptsize
Defining explicit default constructor and copy constructor.\\
\newline
\#include$<$iostream$>$\\
\newline
class C $\lbrace$\\
  int i;\\
public:\\
  C() = default; // Explicit default constructor\\
  C(int j);\\
\newline
  C(const C\& c) = default; // Explicit Default copy constructor\\
$\rbrace$;\\
\newline
C::C(int j) $\lbrace$\\
 i = j;\\
$\rbrace$\\
\newline
int main() $\lbrace$\\
  C c1;\\
  C c2(c1);\\
$\rbrace$\\

}
\subsection{DeletedConstructor.cpp}
\label{DeletedConstructor}
{\scriptsize
Defining explicit deleted constructor and copy constructor.\\
\newline
\#include$<$iostream$>$\\
\newline
class C $\lbrace$\\
public:\\
  C() = delete; // Explicit deleted constructor.\\
  C(const C\& c) = delete; // Explicit deleted copy constructor.\\
$\rbrace$;\\
\newline
int main() $\lbrace$\\
  // C c1;      error no default constructor.\\
  // C c2(c1);  error no default copy constructor.\\
\newline
$\rbrace$\\
}
\subsection{PredefinedVariable\_func.cpp}
{\scriptsize
Using macro \_\_func\_\_, which makes the function name available for use\\
within the function.\\
\newline
\#include $<$iostream$>$\\
\newline
namespace $\lbrace$\\
  void f() $\lbrace$\\
    std::cout $<<$ "Entering function \"" $<<$ \_\_func\_\_ $<<$ "$\backslash$n";\\
    std::cout $<<$ "Size of \_\_func\_\_ = " $<<$ sizeof(\_\_func\_\_) $<<$ "$\backslash$n";\\
  $\rbrace$\\
$\rbrace$\\
\newline
int main() $\lbrace$ f(); $\rbrace$\\
}
%---------------------------
\end{document}