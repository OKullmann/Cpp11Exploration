\documentclass[11pt]{report}

\usepackage{a4}
\usepackage{graphicx}
\usepackage{hyperref}

% For program-code:
\usepackage{listings}
\lstloadlanguages{C++,make}
\newcommand{\Cpp}{\lstset{language=C++,keywordstyle=\bfseries,breaklines,breakindent=30pt}}
\newcommand{\Make}{\lstset{language=make}}
\newcommand{\inl}[1]{\lstinline$#1$}

\Cpp


\begin{document}

\author{Dilshad Sallo\\[1ex]
  Computer Science Department\\
  College of Science, Swansea University\\
  Swansea, SA2 8PP, UK\\[1ex]
  Student Number: 59950\\
  Under Supervision of Dr. Oliver Kullmann
}

\title{C++11 by Examples}

\maketitle



\begin{abstract}

C++11 is new standard that released by C++ committee standard representing the effort of most expert in the world. This version includes new features that addresses some limitations exist in traditional C++ as well as providing new features that never existed in any previous versions. These features support a core language and some libraries and  provide new facilities  to make programming easier than before.

The aim of this project is to investigate some of these features (core \linebreak language features) and providing examples to get most out of them and show them as scientific catalogue to support  ordinary programmers.

This paper focuses on investigating core language features which classify to categories depending in which they belong to. Then, it clearly explains the structure  and  approach of achievement the project which should be mentioned in order to explain how the project will be implemented in the  summer. Finally, it should not be forgotten the important part of this report is the time management which  I use it to arrange the time in the summer to reach the purpose of project.
\end{abstract}

\tableofcontents

% chapter core language
\chapter{Core Language}

\section{Core Language}
\label{section: core language}

\subsection{Core Language Runtime Performance Enhancements}
\label{subsection: Runtime performance}
\begin{enumerate}
\item \textbf{Rvalue references:} 
\item \textbf{Move semantic:}
\item \textbf{Generalized constant expressions - constexpr keyword:} 
\item \textbf{Modification of the definition of plain old data}
\end{enumerate}


\subsection{Core Language Usability Enhancements}
\label{subsection: Usability Enhancements}

\begin{enumerate}
\item \textbf{Uniform initialization:}
\item \textbf{Initializer lists:}

% Auto keyword
\item \textbf{Type inference - Auto keyword:} Many programming languages such Java, C and traditional C++ obligate a programmer to specify data type of variables before initializing and using them in a program. However, with the advent of template types and meta-programming techniques, type names become extremely long and complicated, especially, determining return value of function that used with template classes or using specified names for iterators combined with template classes \cite{Horstmann:2008:BC}.
\newline

In these cases, the data types required for these declarations become complex, ambiguous, and cannot be easily determined by an ordinary programmer.
\newline

C++11 adds significant feature to type inferences called auto keyword, which deduce variable types automatically based on the initializer expression at compile-time.  The auto keyword considers one of the most important features that added to C++11 due to its role to make programming easier to write and understand as well as improving generic programming \cite{Gregorie:professionalcpp}.
\newline

The keyword auto can be used in place of a data type to define build-in types such as int, long and etc, depending on initialization expressions \ref{AutoKeyword_Variable}. It can also be used with const and volatile qualifiers to define const and volatile pointer \ref{AutoKeyword_ConstVolatile}. Additionally, direct initialization syntax with new expressions is permitted by using auto keyword, for instance, the expression auto(1.2) has type double, and thus, new auto(1.2) has type double*. Combination of both will give, auto* d = new auto (1.2). And here, new auto (1.2) has type double*, which will be type of d as well \ref{AutoKeyword_NewExpression} \cite{Stroustrup:2012:Cpp11}.

In many cases, C++ programmers could use some exotic types such as function that return pointer to pointer, and could be hard to determine the return type properly, particularly, when it used with template classes. The auto keyword can be placed in such situation, to let compiler to deduce the data type that is returned from function and making a code easier to write and understand \ref{AutoKeyword_Function} \cite{Overland:2011:CWF}.
\newline

Using auto keyword to infer the type of a variable from initialization is most useful when that type is either difficult to know exactly or difficult to write by a programmer. Suppose a programmer has a map container that maps string to a vector of unsigned an integer as follows: 

\begin{center}
std::map$<$std::string,std::vector$<$unsigned int$>>$ mv;
\end{center}

With traditional C++, if a programmer wanted a constant iterator to the beginning of this map, code will be likely as follows:

\begin{center}
std::map$<$std::string, std::vector<unsigned int$>>$::const\_iterator iter = mv.begin();
\end{center}

However, the auto keyword can be placed instead of this complicated and long type to achieve the same purpose. Additionally, it makes code easier to understand and save a programmer's time, as follows:

\begin{center}
auto iter = mv.begin();
\end{center}

Code of achieving that can be shorter and more robust when a programmer use auto keyword within range-based for statement (which added by C++11), instead of for loop to accomplish the same result \ref{AutoKeyword_MapContainer}. The auto keyword can also be placed instead of class template std::initializer\_list (which added by C++11), to declare an object of the same type in easy way \ref{AutoKeyword_InitializerList} \cite{Gregorie:professionalcpp}.
\newline

The use of keyword has significant role to support generic programming, particularly, template classes. It deduce the type of a variable  during compile- time that depends critically on template argument in such easy way that could not be figure out by a programmer \ref{AutoKeyword_Template} \cite{Stroustrup:2012:Cpp11}.
\newline

The auto keyword has another different usage when it appears with alternative function syntax, which added by C++11. It indicates that function prototype is using alternative function syntax \ref{AlternativeFunction_Syntax}. It could also be served as a place holder for the return type that is deduced or provided later by the alternative function syntax \ref{AlternativeFunction_Template} \cite{Prata:2012:Cpp}.
\newline

The auto keyword is widely used with lambda function, which also added by C++11. As return type of lambda functions is not specified int many cases, the auto keyword uses to deduce return type of function properly, depending on expression that used as return type \ref{Lambda_ImplicitReturn} \cite{Gregorie:professionalcpp}.

% Decltype
\item \textbf{Type inference – Decltype keyword:} C++11 introduces another new type inference called decltype (declared type), which is used to determine the type of an expression at compile-time. The decltype keyword takes as argument an expression, and returns the type associated with that expression \cite{Stroustrup:2012:Cpp11}. 
\newline

The decltype keyword can be used to create different data types depending on an expression that has been used as argument.  If expression is a variable without parenthesized, then the data type will be the same as the expression type \ref{DecltypeKeyword_Variable}. If expression is lvalue (which mean that variable with parenthesized), then the data type will be a reference to that expression type \ref{DecltypeKeyword_lvalue}. Finally, if expression is function call, the data type will be the same as function return type \ref{DecltypeKeyword_Function} \cite{Prata:2012:Cpp}.
\newline

The decltype keyword is pretty useful to deduce type for combination of expressions that could not known by a programmer. This could happen in generic programming, particularly, template classes because the data type is not defined until compile-time. Thus, the decltype keyword allows compiler to go through a check-list to determine the type of expression \ref{DecltypeKeyword_Template} \cite{Stroustrup:2012:Cpp11}.
\newline

The benefit of decltype keyword can also be shown, when it uses as return type for alternative function syntax (which added by C++11) because a return type is not specified in this type of function within templates. Thus, decltype is used as return type to deduce the type from the context of expression \ref{AlternativeFunction_Template} \cite{Gregorie:professionalcpp}. 

% alternative function
\item \textbf{Alternative function syntax:} A function syntax that was designed for C language, is yet using by traditional C++. This old syntax raises some problems and cannot be quite enough for new functionality that has been added to C++11, including deducing return type in the context of declaration \cite{Gregorie:professionalcpp}.
\newline

C++11 introduces a new syntax for declaring functions using a different method to the one that is traditional in C and C++. This notation is known as alternative function syntax, and involves placing the return type at the end of the function signature instead of at the start. Additionally, the auto keyword is placed at the start for the name of the return type, indicating that the prototype is using the alternative function syntax \ref{AlternativeFunction_Syntax} \cite{Gregorie:professionalcpp}.
\newline

Alternative function syntax can be used with decltype keyword to use "this pointer”, which is not otherwise allowed. This is pretty useful with Standard Library container such as vector, to return the first and last value that is pointed by this pointer \ref{AlternativeFunction_This} \cite{ISO:2011:Cpplanguage}. 
\newline

Moreover, using the combination of alternative function syntax and the decltype keyword within templates, solve important problems that could face a programmer, particularly, when a return type is not known exactly.  Consider this situation, when template has two different types, and return type will be the combination of these types, as following:
\begin{center}
template $<$class T1, class T2$>$  ?type? add (T x, U y) 
\newline

\{ return x+y; \}
\end{center}

As it is shown, a type of adding x and y are not known in advance by a programmer. Using the decltype (x + y) alone for return type to address this issue, will cause compiler error, because x and y at the beginning of prototype, are not known.  In other words, they are not in scope, as follows:

\begin{center}
template $<$class T1, class T2$>$  decltype( x + y ) add(T x, U y)
\newline

\{ return x+y; \}
\end{center}

The benefit of alternative function syntax can be gained here by allowing the return type (decltype(x + y)) is specified after the parameter list. Hence, x and y are in the scope and can be used by decltype to deduce return type \ref{AlternativeFunction_Template}. As a result, alternative function syntax and decltype keyword are very useful in the context of specifying the return type of template functions, when a return type is not well known by a programmer\cite{Prata:2012:Cpp}.
\newline

alternative function syntax is not mainly about templates and type deduction, but also about the scope.  With this new syntax, when the scope is written to define function within class, there is no need to add it again to return type because return type goes at the end of the function. Thus, a compiler can reach the return value as it already knows the function is part of class \ref{AlternativeFunction_Scope} \cite{Allain:2011:FutureCpp}.

% Range-based for statement
\item \textbf{Range-based for statement:} C++ supports three types of looping structures namely while loop, do while loop and for loop. In some cases, such iterating over the elements of Standard Library containers including vector and map requires a lot of codes to accomplish iteration properly. Because using these types require create a new variable to store the iterators, and then dereference the iterators using the * operator to get the actual value, as well as initializing the beginning and ending conditions in these forms of loops \cite{Horstmann:2008:BC}.
\newline

C++11 adds a fourth way of looping called the range-based for statement that allows for easy iteration over elements of a list. Range based-for statement is useful technique for writing less code and getting less errors, and can be used with C-style arrays \ref{RangeFor_Array}, initializer lists \ref{RangeFor_InitializerList} and Standard Library containers, that have begin () and end () functions such vector \ref{RangeFor_Vector}. 
\newline

Range based-for statement is much easier to read and understand, and saves programming effort because it does not require initialize the beginning and ending conditions \cite{Overland:2011:CWF}.
\newline

Generally, Range based – for statement comes in two forms: first one is:
\begin{center}
For (base\_type  variable : container)
\end{center} 

This is used to deal with elements of list by value. Thus, the contents of a list cannot be modified \ref{RangeFor_InitializerList}. The second one is:
\begin{center}
For: (base\_type\& variable: container).
\end{center}

This uses reference to be able for modifying the contents of list \ref{RangeFor_Array}.
\newline

The range-based for statement also supports the notion of uniform initialization, for instance, a programmer can simply print a lot of numbers by using this form of loop with brace-initialization. \ref{RangeFor_UniformInitialization} \cite{Overland:2011:CWF}.

% Lambda Expression
\item \textbf{Lambda Expressions:} Traditional C++ includes useful generic functions such as std::for\_each and std::transform, which can be very handy to deal with Standard Library algorithms.  Unfortunately, they can also be quite cumbersome to use, particularly if a functor (functors also called function object, are objects that can be handled though they are a function or function pointer, they are declared by defining member function operator () in class), that would be used as predicates for STL algorithms, are unique to the particular function, because using functor once in specific place seems overkill to be writing whole class just do something trivial and one off \cite{Allain:2011:FutureCpp}. 
\newline

Another reason is that, the function that used by C++ programmers, has C style that  allow each function name to do specific purpose in a program, meaning it must be written separately for each various usage.
\newline

C++11 introduces a new feature called lambda expression (also known as a lambda function) that can be created almost everywhere. Lambda expression considers one of the most exciting features due to its ability to create anonymous functions inline in a source code and greatly simplify it, rather than writing a separate function or a function object.  Thus, the ability of creation functions become quicker and easier, and the code can be easily understood \cite{Gregorie:professionalcpp}.
\newline

This notion may seem a bit weird to those only familiar with the C family of languages, but this is a fairly common feature of most programming languages such as C\#, PHP, JavaScript and Haskell.  
\newline

The syntax of lambda expression can be demonstrated in different styles, depending on purpose that should be achieved. Basically, the general syntax is as follows:
\begin{center}
[capture\_block](parameters) mutable exception\_specification -$>$ return\_type {body}
\end{center}

A lambda expression contains the following parts:
\begin{enumerate}
\item \textbf{Capture block:} this determines how variables (from outside-global variable or inside-local variable) are captured from the enclosing scope, and then make them being available to use inside the function body. there are two methods for capturing all variables from enclosing scope:

      \begin{enumerate}
      \item $[$=$]$ means that a compiler captures all variables by value \ref{Lambda_Mutable}.
      \item $[$\&$]$ means that a compiler captures all variables by reference 
             \ref{Lambda_FunctionParameter}.
      \end{enumerate}
      However, leaving the capture block empty [], tells a compiler not to capture nothing from the enclosing scope \ref{Lambda_Invocation}. \\
      It is also possible to capture variables using both reference and value. This can be done by selectively determine which variables are being captured by reference and then using $[$\&$]$ in front of them. Then, the rest are being captured by value $[$=$]$ as a default capture \cite{Gregorie:professionalcpp}.The default capture must be the first element in the capture list as follow:
      \begin{enumerate}
      \item $[$=, \&a, \&b$]$, capture a and b by reference and the rest by value by default \ref{Lambda_Foreach}.
      \item $[$\&, a$]$, capture by reference by default, except a by value.
      \end{enumerate}
      
      
\item \textbf{Parameters:} : It can be represented by a list of parameters that are used for the lambda expression \ref{Lambda_ExplicitReturn}. This list is optional and can be omitted, if a programmer does not need any parameters for the lambda expression and not specify mutable, nor exception specification and return type \ref{Lambda_Invocation}. The list of parameters in the lambda expression is similar to that in the normal functions, except some restrictions including parameters cannot have default values, unnamed parameters are not allowed and variable length argument lists are not allowed \cite{Cppreference:2012:Cpp11}.

\item \textbf{Mutable:} When variables from the enclosing scope are captured by value, a copy of which will become available inside the lambda expression. By default, those copies are considered as const copies, meaning lambda body cannot modify the value of those copies. If mutable option is inserted to the lambda expression, those copies are become non-const and then can be modified \ref{Lambda_Mutable} \cite{Cppreference:2012:Cpp11}.

\item \textbf{Exception\_specification:} This is optional and uses to determine which exceptions can be thrown by the body of the lambda expression.

\item \textbf{Return\_type:} It is used to specify the type of the returned value such as std::string \ref{Lambda_ExplicitReturn}. This is optional, and If it is not provided, a compiler will decide implicitly the return type according to expression that used for return type \ref{Lambda_ImplicitReturn}, otherwise the return type is considered void \ref{Lambda_Invocation} \cite{Cppreference:2012:Cpp11}.
\end{enumerate}

As a result, a program may not include all these options because they are primarily dependent on a programmer's intend to accomplish specific purpose.
\newline

The lambda expression can be used to print simple string without having any parameters and return type. This can be achieved by parentheses () at the end of the lambda body, which causes to execute the lambda expression immediately \ref{Lambda_Invocation}. It is also possible to store pointer to lambda expression and execute it by the function pointer \ref{Lambda_PointerFunction} \cite{Gregorie:professionalcpp}.
\newline

\textbf{Lambda Expressions as Return Type:} Std::function$<>$ class template, defined in the <functional>, is polymorphic function object wrapper and is considered one of the great new features that introduced by C++11, due to its ability to wrap to callable objects ( function pointers, function object and lambdas) as long as there is compatibility in terms of argument  and return type with those of the wrapper.
\newline

Therefore, the new std::function is an extremely useful way for passing around lambda functions as return values and by doing that, lambda expressions can be returned from ordinary functions. \ref{Lambda_FunctionReturnType} \cite {Josuttis:2012:CppStandard Library}.
\newline

\textbf{Lambda Expressions as Parameters:} The std::function can be also used to pass around lambda expression as parameters. Thus, it is possible to defining ordinary functions that take lambda expression as parameter to implement callback functions \ref{Lambda_FunctionParameter} \cite{Allain:2011:FutureCpp}.
\newline

Using lambda expression as parameters has significant impact over Standard Library algorithm and without doubt, it is the biggest beneficiaries of lambda expressions, because previously, using algorithms such as std::sort and std::for\_each require writing separate code to accomplish their purposes. But now, lambda can be placed as third parameter to achieve the same purpose, without writing separate functions \ref{Lambda_Foreach}, \ref{Lambda_Sort} \cite {Gregorie:professionalcpp}.
\newline

As a result, lambda expression is significant step forward, and improves code clarity and makes programming easier.


\item \textbf{Delegating constructors: }
\item \textbf{Override keyword:}
\item \textbf{Final keyword:}
\item \textbf{Null pointer constant:}
\item \textbf{Strongly typed enumerations:}
\item \textbf{Alias templates:}
\end{enumerate}


\subsection{Core Language Functionality Improvements}
\label{subsection: Functionality Improvements}
\begin{enumerate}
\item \textbf{New character types : char16\_t and char32\_t}
\item \textbf{Raw string literals:}
\item \textbf{User-defined literals:}
\item \textbf{Explicitly Defaulted special member functions:}
\item \textbf{Explicitly Deleted special member functions:}
\item \textbf{Unsigned long long (int) and long long (int):} 
\item \textbf{Static assertion:}
\item \textbf{Variadic template:}
\end{enumerate}



\addcontentsline{toc}{section}{Bibliography}
\bibliographystyle{alpha}
\bibliography{Bibliography}	


\begin{appendix}

\chapter{Program Code}
\label{chapter:Programcode}


\section{MakeFile}
\label{Makefile}

\Make

\lstinputlisting{../Makefile.}
\newpage


% Core language Runtime Performance Enhancements
\section{Core Language Runtime Performance Enhancements}
\label{Appendix: corelanguage runtime performance}

\Cpp

\subsection{RvalueReference\_Basic.cpp}
\label{sub:RvalueReference_Basic}
%\lstinputlisting{../CoreLanguage/RunTime/RvalueReference_Basic.cpp}


% Core Language Usability Enhancements
\section{Core Language Usability Enhancements}
\label{Appendix: corelanguage usabiliy enhancements}

\Cpp

% Auto keyword
\subsection{AutoKeyword\_Variable.cpp}
\label{AutoKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Variable.cpp}

\subsection{AutoKeyword\_ConstVolatile.cpp}
\label{AutoKeyword_ConstVolatile}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_ConstVolatile.cpp}

\subsection{AutoKeyword\_NewExpression.cpp}
\label{AutoKeyword_NewExpression}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_NewExpression.cpp}

\subsection{AutoKeyword\_Function.cpp}
\label{AutoKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Function.cpp}

\subsection{AutoKeyword\_MapContainer.cpp}
\label{AutoKeyword_MapContainer}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_MapContainer.cpp}

\subsection{AutoKeyword\_InitializerList.cpp}
\label{AutoKeyword_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_InitializerList.cpp}

\subsection{AutoKeyword\_Template.cpp}
\label{AutoKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AutoKeyword_Template.cpp}

% Decltype keyword
\subsection{DecltypeKeyword\_Variable.cpp}
\label{DecltypeKeyword_Variable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Variable.cpp}

\subsection{DecltypeKeyword\_lvalue.cpp}
\label{DecltypeKeyword_lvalue}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_lvalue.cpp}

\subsection{DecltypeKeyword\_Function.cpp}
\label{DecltypeKeyword_Function}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Function.cpp}

\subsection{DecltypeKeyword\_Template.cpp}
\label{DecltypeKeyword_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/DecltypeKeyword_Template.cpp}

% alternative function syntax
\subsection{AlternativeFunction\_Syntax.cpp}
\label{AlternativeFunction_Syntax}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Syntax.cpp}

\subsection{AlternativeFunction\_This.cpp}
\label{AlternativeFunction_This}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_This.cpp}

\subsection{AlternativeFunction\_Template.cpp}
\label{AlternativeFunction_Template}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Template.cpp}

\subsection{AlternativeFunction\_Scope.cpp}
\label{AlternativeFunction_Scope}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/AlternativeFunction_Scope.cpp}

% Ragne-based for statement
\subsection{RangeFor\_Array.cpp}
\label{RangeFor_Array}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Array.cpp}

\subsection{RangeFor\_InitializerList.cpp}
\label{RangeFor_InitializerList}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_InitializerList.cpp}

\subsection{RangeFor\_Vector.cpp}
\label{RangeFor_Vector}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_Vector.cpp}

\subsection{RangeFor\_UniformInitialization.cpp}
\label{RangeFor_UniformInitialization}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/RangeFor_UniformInitialization.cpp}

% Lambda Expression
\subsection{Lambda\_Mutable.cpp}
\label{Lambda_Mutable}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Mutable.cpp}

\subsection{Lambda\_FunctionParameter.cpp}
\label{Lambda_FunctionParameter}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionParameter.cpp}

\subsection{Lambda\_Invocation.cpp}
\label{Lambda_Invocation}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Invocation.cpp}

\subsection{Lambda\_Foreach.cpp}
\label{Lambda_Foreach}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Foreach.cpp}

\subsection{Lambda\_ExplicitReturn.cpp}
\label{Lambda_ExplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ExplicitReturn.cpp}

\subsection{Lambda\_ImplicitReturn.cpp}
\label{Lambda_ImplicitReturn}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_ImplicitReturn.cpp}

\subsection{Lambda\_PointerFunction.cpp}
\label{Lambda_PointerFunction}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_PointerFunction.cpp}

\subsection{Lambda\_FunctionReturnType.cpp}
\label{Lambda_FunctionReturnType}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_FunctionReturnType.cpp}

\subsection{Lambda\_Sort.cpp}
\label{Lambda_Sort}
\lstinputlisting{../CoreLanguage/UsabilityEnhancements/Lambda_Sort.cpp}

% Core Language Functionality Improvements
\section{Core Language Functionality Improvements}
\label{Appendix: corelanguage functionality improvements}

\Cpp

\subsection{}
\label{}
%\lstinputlisting{../CoreLanguage/FunctionalityImprovements/



\end{appendix}

\end{document}
